<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8"/>
    <meta name="viewport" content="initial-scale=1.0, width=device-width"/>
    <title>
      
        150题 | 饿了
      
    </title>
    <meta name="description" content=""/>
    <meta name="keywords" content=""/>
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/apple-touch-icon.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/favicon-32x32.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/favicon-16x16.png"/>
    
    
      <link rel="mask-icon"
            href="/images/logo.svg"
            color=""/>
    
    
    
      
  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/regular.ttf);
        font-weight: regular;
    }
  </style>

  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/bold.ttf);
        font-weight: bold;
    }
  </style>


    
    <link rel="stylesheet"
          type="text/css"
          href='/css/layout.css'/>
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css" />
  

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="head">
      <div class="nav">
        <a href='/' class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/logo.svg"/>
        </a>
        <input id="navBtn" type="checkbox"/>
        <div class="nav-menu">
          
            
              <a class="nav-menu-item" href="/java">技术</a>
            
              <a class="nav-menu-item" href="/paper">论文</a>
            
          
          
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner">
      <div class="post-content__head">
        <div class="post-title">150题</div>
        <div class="post-info">
          
  <a href="/tags/%E7%AE%97%E6%B3%95/" class="post-tag">#算法</a>


          <span class="post-date">2024-01-17</span>
        </div>
      </div>
      
      <div class="post-content__body">
        
          <div class="post-gallery">
            
          </div>
        
        <h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] sorted = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p1&lt;m||p2&lt;n)&#123;<br>            <span class="hljs-keyword">if</span> (p1 == m)&#123;<br>                cur = nums2[p2++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 == n)&#123;<br>                cur = nums1[p1++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[p1]&lt;nums2[p2])&#123;<br>                cur = nums1[p1++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = nums2[p2++];<br>            &#125;<br><br>            sorted[p1+p2-<span class="hljs-number">1</span>]=cur;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; nums1.length; i++)&#123;<br>            nums1[i] = sorted[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 $O(m+n)$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;<br>        int len1 = m - 1;<br>        int len2 = n - 1;<br>        int len = m + n - 1;<br>        while(len1 &gt;= 0 &amp;&amp; len2 &gt;= 0) &#123;<br>            // 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码<br>            nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];<br>        &#125;<br>        // 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1<br>        System.arraycopy(nums2, 0, nums1, 0, len2 + 1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int removeElement(int[] nums, int val) &#123;<br>        int idx = 0;<br>        for(int num : nums)&#123;<br>            if(num!=val)&#123;<br>                nums[idx++] = num;<br>            &#125;<br>        &#125;<br><br>        return idx;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="删除有序数组的重复项"><a href="#删除有序数组的重复项" class="headerlink" title="删除有序数组的重复项"></a>删除有序数组的重复项</h2><p>给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p>
<p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p>
<p>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int removeDuplicates(int[] nums) &#123;<br>        int idx = 0;<br>        for (int i=0;i&lt;nums.length - 1;i++)&#123;<br>            if(nums[i]!=nums[i+1])<br>                nums[idx++] = nums[i];<br>        &#125;<br>        nums[idx++] = nums[nums.length - 1];<br>        return idx;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>改进: 数组中没有重复元素，按照上面的方法，每次比较时 nums[p] 都不等于 nums[q]，因此就会将 q 指向的元素原地复制一遍，这个操作其实是不必要的。</p>
<p>因此我们可以添加一个小判断，当 q - p &gt; 1 时，才进行复制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public int removeDuplicates(int[] nums) &#123;<br>    if(nums == null || nums.length == 0) return 0;<br>    int p = 0;<br>    int q = 1;<br>    while(q &lt; nums.length)&#123;<br>        if(nums[p] != nums[q])&#123;<br>            if(q - p &gt; 1)&#123;<br>                nums[p + 1] = nums[q];<br>            &#125;<br>            p++;<br>        &#125;<br>        q++;<br>    &#125;<br>    return p + 1;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="删除有序数组的重复项2"><a href="#删除有序数组的重复项2" class="headerlink" title="删除有序数组的重复项2"></a>删除有序数组的重复项2</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int removeDuplicates(int[] nums) &#123;<br>        int idx = 0;<br><br>        for(int i=idx+2; i&lt;nums.length;i++)&#123;<br>            if(nums[idx] != nums[i])&#123;<br>                nums[idx+2] = nums[i];<br>                idx++;<br>            &#125;<br>        &#125;<br><br>        return idx+2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>计数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int removeDuplicates(int[] nums) &#123;<br>        int left=0,right=0,n=nums.length;<br>        int preNum = nums[0],cnt=0;<br>        while(right&lt;n)&#123;<br>            if(nums[right]==preNum)&#123;<br>                cnt++;<br>                if(cnt&gt;2)&#123;<br>                    right++;<br>                    continue;<br>                &#125;<br>            &#125;else&#123;<br>                preNum = nums[right];<br>                cnt=1;<br>            &#125;<br>            nums[left++]=nums[right++];<br>        &#125;<br>        return left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int majorityElement(int[] nums) &#123;<br>        Map&lt;Integer, Integer&gt; mp = new HashMap&lt;Integer, Integer&gt;();<br><br>        for(int i = 0; i&lt;nums.length;i++)&#123;<br>            if(mp.get(nums[i])==null)&#123;<br>                mp.put(nums[i], 1);<br>            &#125;else&#123;<br>                int temp = mp.get(nums[i]) + 1;<br>                mp.put(nums[i], temp);<br>            &#125;<br>        &#125;<br><br>        for(Map.Entry&lt;Integer, Integer&gt; entry: mp.entrySet())&#123;<br>            if(entry.getValue()&gt;(nums.length/2))&#123;<br>                return entry.getKey();<br>            &#125;<br>        &#125;<br><br>        return 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int majorityElement(int[] nums) &#123;<br>        Arrays.sort(nums);<br>        return nums[nums.length / 2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public void rotate(int[] nums, int k) &#123;<br>        int[] temp = new int[nums.length];<br>        for(int i=0;i&lt;nums.length;i++)&#123;<br>            temp[(i+k)%nums.length] = nums[i];<br>        &#125;<br><br>        System.arraycopy(temp, 0, nums, 0, nums.length);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="环状替换"><a href="#环状替换" class="headerlink" title="环状替换"></a>环状替换</h3><p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/images/202401181212652.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public void rotate(int[] nums, int k) &#123;<br>        int n = nums.length;<br>        k = k % n;<br>        int count = gcd(k, n);<br>        for (int start = 0; start &lt; count; ++start) &#123;<br>            int current = start;<br>            int prev = nums[start];<br>            do &#123;<br>                int next = (current + k) % n;<br>                int temp = nums[next];<br>                nums[next] = prev;<br>                prev = temp;<br>                current = next;<br>            &#125; while (start != current);<br>        &#125;<br>    &#125;<br><br>    public int gcd(int x, int y) &#123;<br>        return y &gt; 0 ? gcd(y, x % y) : x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public void rotate(int[] nums, int k) &#123;<br>        reverse(nums, 0, nums.length-1);<br>        reverse(nums, 0, k-1);<br>        reverse(nums,k,nums.length-1);<br><br>    &#125;<br><br>    public void reverse(int[] nums, int start, int end)&#123;<br>        while(start&lt;end)&#123;<br>            int temp = nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = temp;<br><br>            start++;<br>            end--;<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int maxProfit(int[] prices) &#123;<br>        int count = 0;<br>        int min = 10000;<br>        for(int i=0; i&lt;prices.length; i++)&#123;<br>            if(prices[i]&lt;min)<br>                min = prices[i];<br>            if(count&lt;(prices[i]-min))<br>                count = prices[i]-min;<br><br>        &#125;<br><br>        return count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机2"><a href="#买卖股票的最佳时机2" class="headerlink" title="买卖股票的最佳时机2"></a>买卖股票的最佳时机2</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p>贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int maxProfit(int[] prices) &#123;<br>        int count = 0;<br>        for(int i=0; i&lt;prices.length-1;i++)&#123;<br>            if(prices[i+1]&gt;prices[i])&#123;<br>                count += prices[i+1] - prices[i];<br>            &#125;<br>        &#125;<br><br>        return count;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>动态规划</p>
<p>第 1 步：定义状态</p>
<p>状态 dp[i][j] 定义如下：</p>
<p>dp[i][j] 表示到下标为 i 的这一天，持股状态为 j 时，我们手上拥有的最大现金数。</p>
<p>注意：限定持股状态为 j 是为了方便推导状态转移方程，这样的做法满足 无后效性。</p>
<p>其中：</p>
<p>第一维 i 表示下标为 i 的那一天（ 具有前缀性质，即考虑了之前天数的交易 ）；<br>第二维 j 表示下标为 i 的那一天是持有股票，还是持有现金。这里 0 表示持有现金（cash），1 表示持有股票（stock）。<br>第 2 步：思考状态转移方程</p>
<p>状态从持有现金（cash）开始，到最后一天我们关心的状态依然是持有现金（cash）；<br>每一天状态可以转移，也可以不动。</p>
<p>说明：</p>
<p>由于不限制交易次数，除了最后一天，每一天的状态可能不变化，也可能转移；<br>写代码的时候，可以不用对最后一天单独处理，输出最后一天，状态为 0 的时候的值即可。<br>第 3 步：确定初始值</p>
<p>起始的时候：</p>
<p>如果什么都不做，dp[0][0] &#x3D; 0；<br>如果持有股票，当前拥有的现金数是当天股价的相反数，即 dp[0][1] &#x3D; -prices[i]；<br>第 4 步：确定输出值</p>
<p>终止的时候，上面也分析了，输出 dp[len - 1][0]，因为一定有 dp[len - 1][0] &gt; dp[len - 1][1]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Solution &#123;<br><br>    public int maxProfit(int[] prices) &#123;<br>        int len = prices.length;<br>        if (len &lt; 2) &#123;<br>            return 0;<br>        &#125;<br><br>        // 0：持有现金<br>        // 1：持有股票<br>        // 状态转移：0 → 1 → 0 → 1 → 0 → 1 → 0<br>        int[][] dp = new int[len][2];<br><br>        dp[0][0] = 0;<br>        dp[0][1] = -prices[0];<br><br>        for (int i = 1; i &lt; len; i++) &#123;<br>            // 这两行调换顺序也是可以的<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);<br>        &#125;<br>        return dp[len - 1][0];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean canJump(int[] nums) &#123;<br>        int k = 0;<br>        for(int i=0;i&lt;nums.length;i++)&#123;<br>            if(i&gt;k) return false;<br>            k = Math.max(k, i+nums[i]);<br>        &#125;<br><br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h2><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>
<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。返回到达 nums[n - 1] 的最小跳跃次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int jump(int[] nums) &#123;<br>        int ans = 0;<br>        int end = 1;<br>        int k = 0;<br><br>        for(int i=0;i&lt;nums.length;i++)&#123;<br>            k = Math.max(k, i+nums[i]);<br>            if(i == end)&#123;<br>                end = k;<br>                ans++;<br>            &#125;<br>        &#125;<br><br>        return ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int jump(int[] nums) &#123;<br>        int ans = 0;<br>        int end = 0;<br>        int begin = 0;<br><br>        while(end&lt;nums.length-1)&#123;<br>            int temp = 0;<br><br>            for(int i = begin; i&lt;=end; i++)&#123;<br>                temp = Math.max(i+nums[i], temp);<br>            &#125;<br><br>            begin = end + 1;<br>            end = temp;<br>            ans++;<br>        &#125;<br><br>        return ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="H指数"><a href="#H指数" class="headerlink" title="H指数"></a>H指数</h2><p>给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。</p>
<p>根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int hIndex(int[] citations) &#123;<br>        Arrays.sort(citations);<br>        int h = 0, i = citations.length - 1;<br>        while(i&gt;= 0 &amp;&amp; citations[i]&gt;h)&#123;<br>            h++;<br>            i--;<br>        &#125;<br><br>        return h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>计数排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Solution &#123;<br>    public int hIndex(int[] citations) &#123;<br>        int n = citations.length, tot = 0;<br>        int[] counter = new int[n + 1];<br>        for (int i = 0; i &lt; n; i++) &#123;<br>            if (citations[i] &gt;= n) &#123;<br>                counter[n]++;<br>            &#125; else &#123;<br>                counter[citations[i]]++;<br>            &#125;<br>        &#125;<br>        for (int i = n; i &gt;= 0; i--) &#123;<br>            tot += counter[i];<br>            if (tot &gt;= i) &#123;<br>                return i;<br>            &#125;<br>        &#125;<br>        return 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>二分查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int hIndex(int[] citations) &#123;<br>        int left = 0,right = citations.length;<br>        int count = 0, mid = 0;<br><br>        while(left&lt;right)&#123;<br>            mid = (left+right+1)&gt;&gt;1;<br><br>            count = 0;<br>            for(int i =0; i&lt; citations.length;i++)&#123;<br>                if(citations[i]&gt;=mid)<br>                    count++;<br>            &#125;<br><br>            if(count&gt;=mid)<br>                left = mid;<br>            else<br>                right = mid -1;<br>            <br>        &#125;<br>        return left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="O-1-时间插入，删除和获取随机元素"><a href="#O-1-时间插入，删除和获取随机元素" class="headerlink" title="O(1)时间插入，删除和获取随机元素"></a>O(1)时间插入，删除和获取随机元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class RandomizedSet &#123;<br>    Random rd;<br>    Map&lt;Integer, Integer&gt; mp;<br>    int idx;<br>    static int[] nums = new int[200010];<br><br>    public RandomizedSet() &#123;<br>        rd = new Random();<br>        mp = new HashMap();<br>        idx = -1;<br>    &#125;<br>    <br>    public boolean insert(int val) &#123;<br>        if(!mp.containsKey(val))&#123;<br>            nums[++idx] = val;<br>            mp.put(val, idx);<br>            return true;<br>        &#125;else&#123;<br>            return false;<br>        &#125;<br>            <br>    &#125;<br>    <br>    public boolean remove(int val) &#123;<br>        if(mp.containsKey(val))&#123;<br>            int loc = mp.remove(val);<br>            if(loc != idx) mp.put(nums[idx], loc);<br>            nums[loc] = nums[idx--];<br>            return true;<br>        &#125;else&#123;<br>            return false;<br>        &#125;<br>    &#125;<br>    <br>    public int getRandom() &#123;<br>        return nums[rd.nextInt(idx + 1)];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="出自身以外元素的乘积"><a href="#出自身以外元素的乘积" class="headerlink" title="出自身以外元素的乘积"></a>出自身以外元素的乘积</h2><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p>
<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p>
<p>请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int[] productExceptSelf(int[] nums) &#123;<br>        int[] answer = new int[nums.length];<br><br>        int[] left = new int[nums.length];<br>        int[] right = new int[nums.length];<br><br>        left[0] = 1;<br>        for(int i=1; i&lt;nums.length; i++)&#123;<br>            left[i] = left[i - 1] * nums[i -1];<br>        &#125;<br><br>        right[nums.length - 1] = 1;<br><br>        for(int i=nums.length -2;i&gt;=0;i--)&#123;<br>            right[i] = right[i+1]*nums[i+1];<br>        &#125;<br><br>        for(int i = 0;i&lt;nums.length;i++)&#123;<br>            answer[i] = left[i] * right[i];<br>        &#125;<br><br>        return answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>改进</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int[] productExceptSelf(int[] nums) &#123;<br>        int length = nums.length;<br>        int[] answer = new int[length];<br><br>        // answer[i] 表示索引 i 左侧所有元素的乘积<br>        // 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 answer[0] = 1<br>        answer[0] = 1;<br>        for (int i = 1; i &lt; length; i++) &#123;<br>            answer[i] = nums[i - 1] * answer[i - 1];<br>        &#125;<br><br>        // R 为右侧所有元素的乘积<br>        // 刚开始右边没有元素，所以 R = 1<br>        int R = 1;<br>        for (int i = length - 1; i &gt;= 0; i--) &#123;<br>            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R<br>            answer[i] = answer[i] * R;<br>            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上<br>            R *= nums[i];<br>        &#125;<br>        return answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int canCompleteCircuit(int[] gas, int[] cost) &#123;<br>        int n = gas.length;<br>        int i = 0;<br><br>        while(i&lt;n)&#123;<br>            int sum_g = 0,sum_c = 0;<br>            int count = 0;<br><br>            while(count &lt; n)&#123;<br>                int j = (i+count)%n;<br>                sum_g += gas[j];<br>                sum_c += cost[j];<br><br>                if(sum_g&lt;sum_c)<br>                    break;<br><br>                count++;<br>            &#125;<br><br>            if(count == n)&#123;<br>                return i;<br>            &#125;else&#123;<br>                i = i + count + 1;<br>            &#125;<br><br><br>        &#125;<br><br>        return -1;<br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>class Solution &#123;<br>    public int candy(int[] ratings) &#123;<br>        int n = ratings.length;<br>        int[] left = new int[n];<br><br>        for(int i=0;i&lt;n;i++)&#123;<br>            if(i&gt;0 &amp;&amp; ratings[i]&gt;ratings[i-1])&#123;<br>                left[i] = left[i-1]+1;<br>            &#125;else&#123;<br>                left[i] = 1;<br>            &#125;<br>        &#125;<br><br>        int right = 0, count = 0;<br><br>        for(int i = n-1; i&gt;=0; i--)&#123;<br>            if(i&lt;n-1 &amp;&amp; ratings[i]&gt;ratings[i+1])&#123;<br>                right++;<br>            &#125;else&#123;<br>                right = 1;<br>            &#125;<br><br>            count += Math.max(left[i], right);<br>        &#125;<br><br>        return count;<br>    &#125;<br><br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>




<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>按行来（超时）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int n = height.length;<br>        int m = getMax(height);<br>        int sum = 0;<br>        for(int i=1;i&lt;=m;i++)&#123;<br>            boolean isStart = false;<br>            int temp = 0;<br>            for(int j = 0; j&lt;n; j++)&#123;<br>                if(isStart &amp;&amp; height[j]&lt;i)&#123;<br>                    temp++;<br>                &#125;<br>                if(height[j]&gt;=i)&#123;<br>                    sum = sum + temp;<br>                    temp = 0;<br><br>                    isStart = true;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        return sum;<br>    &#125;<br><br>    public int getMax(int[] height)&#123;<br>        int max = 0;<br>        for(int i=0; i&lt;height.length;i++)&#123;<br>            if(max&lt;height[i])<br>                max = height[i];<br>        &#125;<br>        <br>        return max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>按列算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int sum = 0;<br>        for(int i= 1;i&lt;height.length-1;i++)&#123;<br>            int max_left = 0;<br>            for(int j = i - 1;j&gt;=0;j--)&#123;<br>                if(height[j]&gt;max_left)<br>                    max_left = height[j];<br>            &#125;<br><br>            int max_right = 0;<br><br>            for(int j=i+1;j&lt;height.length;j++)&#123;<br>                if(height[j]&gt;max_right)<br>                    max_right = height[j];<br>            &#125;<br><br>            int min = Math.min(max_left, max_right);<br><br>            if(min&gt;height[i])&#123;<br>                sum += (min - height[i]);<br>            &#125;<br>        &#125;<br><br>        return sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int sum = 0;<br><br>        int[] max_left = new int[height.length];<br>        int[] max_right = new int[height.length];<br><br>        for(int i =1;i&lt;height.length-1;i++)&#123;<br>            max_left[i]= Math.max(max_left[i-1], height[i-1]);<br>        &#125;<br><br>        for(int i = height.length - 2; i&gt;=0;i--)&#123;<br>            max_right[i] = Math.max(max_right[i+1], height[i+1]);<br>        &#125;<br><br>        for(int i=1;i&lt;height.length-1;i++)&#123;<br>            int min = Math.min(max_left[i], max_right[i]);<br>            if(min&gt;height[i])&#123;<br>                sum += (min - height[i]);<br>            &#125;<br>        &#125;<br><br>        return sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int sum = 0;<br>        int max_left = 0;<br>        int[] max_right = new int[height.length];<br>        for (int i = height.length - 2; i &gt;= 0; i--) &#123;<br>            max_right[i] = Math.max(max_right[i + 1], height[i + 1]);<br>        &#125;<br>        for (int i = 1; i &lt; height.length - 1; i++) &#123;<br>            max_left = Math.max(max_left, height[i - 1]);<br>            int min = Math.min(max_left, max_right[i]);<br>            if (min &gt; height[i]) &#123;<br>                sum = sum + (min - height[i]);<br>            &#125;<br>        &#125;<br>        return sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int romanToInt(String s) &#123;<br>        char[] chars = s.toCharArray();<br>        int[] ints = new int[chars.length];<br>        for (int i = 0; i &lt; chars.length; i++) &#123;<br>            ints[i] = getValue(chars[i]);<br>        &#125;<br>        int sum = 0;<br>        for (int i = 0; i &lt; ints.length; i++) &#123;<br>            if (i &lt; ints.length - 1 &amp;&amp; ints[i] &lt; ints[i + 1]) &#123;<br>                ints[i] *= -1;<br>            &#125;<br>            sum += ints[i];<br>        &#125;<br>        return sum;<br>    &#125;<br><br>    private int getValue(char romanChar) &#123;<br>        switch (romanChar) &#123;<br>            case &#x27;I&#x27; -&gt; &#123;<br>                return 1;<br>            &#125;<br>            case &#x27;V&#x27; -&gt; &#123;<br>                return 5;<br>            &#125;<br>            case &#x27;X&#x27; -&gt; &#123;<br>                return 10;<br>            &#125;<br>            case &#x27;L&#x27; -&gt; &#123;<br>                return 50;<br>            &#125;<br>            case &#x27;C&#x27; -&gt; &#123;<br>                return 100;<br>            &#125;<br>            case &#x27;D&#x27; -&gt; &#123;<br>                return 500;<br>            &#125;<br>            case &#x27;M&#x27; -&gt; &#123;<br>                return 1000;<br>            &#125;<br>            default -&gt; &#123;<br>                return 0;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给你一个整数，将其转为罗马数字。</p>
<p>模拟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;<br>    String[] symbols = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;<br><br>    public String intToRoman(int num) &#123;<br>        StringBuffer roman = new StringBuffer();<br><br>        for(int i=0;i&lt;values.length;i++)&#123;<br>            int value = values[i];<br>            String symbol = symbols[i];<br><br>            while(num&gt;=value)&#123;<br>                num -= value;<br>                roman.append(symbol);<br>            &#125;<br>            if(num == 0)&#123;<br>                break;<br>            &#125;<br>        &#125;<br><br>        return roman.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>硬编码</p>
<p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/images/202401241339638.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    String[] thousands = &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;;<br>    String[] hundreds  = &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;;<br>    String[] tens      = &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;;<br>    String[] ones      = &#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;;<br><br>    public String intToRoman(int num) &#123;<br>        StringBuffer roman = new StringBuffer();<br>        roman.append(thousands[num / 1000]);<br>        roman.append(hundreds[num % 1000 / 100]);<br>        roman.append(tens[num % 100 / 10]);<br>        roman.append(ones[num % 10]);<br>        return roman.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h2><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p>
<p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int lengthOfLastWord(String s) &#123;<br>        int end = s.length() - 1;<br>        while(end&gt;=0&amp;&amp; s.charAt(end) == &#x27; &#x27;) end--;<br>        if(end&lt;0) return 0;<br>        int start = end;<br>        while(start&gt;=0 &amp;&amp; s.charAt(start)!= &#x27; &#x27;) start--;<br>        return end-start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p>横向扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String longestCommonPrefix(String[] strs) &#123;<br>        if(strs == null || strs.length == 0)<br>            return &quot;&quot;;<br><br>        String pre = strs[0];<br>        for(int i=1;i&lt;strs.length;i++)&#123;<br>            pre = common(pre, strs[i]);<br>            if(pre.length()==0)<br>                break;<br>        &#125;<br><br>        return pre;<br>    &#125;<br><br>    public String common(String str1, String str2)&#123;<br>        int length = Math.min(str1.length(), str2.length());<br><br>        int index = 0;<br>        while(index&lt;length&amp;&amp;str1.charAt(index) == str2.charAt(index))<br>            index++;<br>        <br>        return str1.substring(0, index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>纵向扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String longestCommonPrefix(String[] strs) &#123;<br>        if (strs == null || strs.length == 0) &#123;<br>            return &quot;&quot;;<br>        &#125;<br><br>        int length = strs[0].length();<br>        int count = strs.length;<br><br>        for(int i=0; i&lt;length;i++)&#123;<br>            char c = strs[0].charAt(i);<br>            for(int j = 1;j&lt;count;j++)&#123;<br>                if(i == strs[j].length()||strs[j].charAt(i)!=c)<br>                    return strs[0].substring(0, i);<br>            &#125;<br>        &#125;<br><br>        return strs[0];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h2><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String reverseWords(String s) &#123;<br>        s = s.trim();<br>        int length = s.length() ;<br>        StringBuilder ans = new StringBuilder();<br><br>        for(int i = length -1;i&gt;=0;i--)&#123;<br>             while(i&gt;=0 &amp;&amp; s.charAt(i) ==&#x27; &#x27;)&#123;<br>                --i;<br>            &#125;<br>            int end = i;<br>            if(i&lt;0)&#123;<br>                break;<br>            &#125;<br><br>            while(i&gt;=0 &amp;&amp; s.charAt(i)!=&#x27; &#x27;)&#123;<br>                i--;<br>            &#125;<br><br>            ans.append(&quot; &quot;).append(s.substring(i+1, end+1));<br>        &#125;<br><br>        return ans.toString().trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p>
<p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String convert(String s, int numRows) &#123;<br>        int n = s.length(), r = numRows;<br>        if (r == 1 || r &gt;= n) &#123;<br>            return s;<br>        &#125;<br>        int t = r*2 - 2;<br>        int c = (n+t-1)/t * (r-1);<br><br><br>        char[][] mat = new char[r][c];<br><br>        for(int i=0, x=0, y=0;i&lt;s.length();i++)&#123;<br>            mat[x][y] = s.charAt(i);<br>            if(i%t&lt;r-1)&#123;<br>                ++x;<br>            &#125;else&#123;<br>                --x;<br>                ++y;<br>            &#125;<br>        &#125;<br><br>        StringBuffer ans = new StringBuffer();<br>        for(char[] row: mat)&#123;<br>            for(char ch: row)&#123;<br>                if(ch!=0)&#123;<br>                    ans.append(ch);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        return ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>flag </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String convert(String s, int numRows) &#123;<br>        if(numRows&lt;2) return s;<br>        List&lt;StringBuffer&gt; rows = new ArrayList&lt;StringBuffer&gt;();<br><br>        for(int i=0;i&lt;numRows;i++) rows.add(new StringBuffer());<br><br>        int i=0, flag = -1;<br><br>        for(char c:s.toCharArray())&#123;<br>            rows.get(i).append(c);<br><br>            if(i == 0 || i == numRows - 1) flag = -flag;<br><br>            i+= flag;<br>        &#125;<br>        StringBuffer res = new StringBuffer();<br>        for(StringBuffer row : rows) res.append(row);<br><br>        return res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="找出字符串中第一个匹配的下标"><a href="#找出字符串中第一个匹配的下标" class="headerlink" title="找出字符串中第一个匹配的下标"></a>找出字符串中第一个匹配的下标</h2><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int strStr(String haystack, String needle) &#123;<br>        int n = needle.length();<br>        int length  = haystack.length();<br>        int ans = -1;<br>        for(int i=0;i&lt;=length - n;i++)&#123;<br>            String temp = haystack.substring(i, i+n);<br><br>            if(equals(temp, needle))&#123;<br>                ans = i;<br>                break;<br>            &#125;<br>        &#125;<br><br>        return ans;<br>    &#125;<br><br>    public boolean equals(String s_1, String s_2)&#123;<br>        char[] s1 = s_1.toCharArray(), s2 = s_2.toCharArray();<br>        int n = s_1.length(), m = s_2.length();<br>        if(n!=m)<br>            return false;<br>        for(int i=0;i&lt;n;i++)&#123;<br>            if(s1[i]!=s2[i])<br>                return false;<br>        &#125;<br><br>        return true;<br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>KMP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    // KMP 算法<br>    // ss: 原串(string)  pp: 匹配串(pattern)<br>    public int strStr(String ss, String pp) &#123;<br>        if (pp.isEmpty()) return 0;<br>        <br>        // 分别读取原串和匹配串的长度<br>        int n = ss.length(), m = pp.length();<br>        // 原串和匹配串前面都加空格，使其下标从 1 开始<br>        ss = &quot; &quot; + ss;<br>        pp = &quot; &quot; + pp;<br><br>        char[] s = ss.toCharArray();<br>        char[] p = pp.toCharArray();<br><br>        // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）<br>        int[] next = new int[m + 1];<br>        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】<br>        for (int i = 2, j = 0; i &lt;= m; i++) &#123;<br>            // 匹配不成功的话，j = next(j)<br>            while (j &gt; 0 &amp;&amp; p[i] != p[j + 1]) j = next[j];<br>            // 匹配成功的话，先让 j++<br>            if (p[i] == p[j + 1]) j++;<br>            // 更新 next[i]，结束本次循环，i++<br>            next[i] = j;<br>        &#125;<br><br>        // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】<br>        for (int i = 1, j = 0; i &lt;= n; i++) &#123;<br>            // 匹配不成功 j = next(j)<br>            while (j &gt; 0 &amp;&amp; s[i] != p[j + 1]) j = next[j];<br>            // 匹配成功的话，先让 j++，结束本次循环后 i++<br>            if (s[i] == p[j + 1]) j++;<br>            // 整一段匹配成功，直接返回下标<br>            if (j == m) return i - m;<br>        &#125;<br><br>        return -1;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="文本左右对齐"><a href="#文本左右对齐" class="headerlink" title="文本左右对齐"></a>文本左右对齐</h2><p>给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p>
<p>你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ‘ ‘ 填充，使得每行恰好有 maxWidth 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">fullJustify</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> maxWidth)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = words.length;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> right;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sumlen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(right&lt;n &amp;&amp; sumlen + words[right].length() + right - left &lt;= maxWidth)&#123;<br>                sumlen += words[right++].length();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(right == n)&#123;<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> join(words, left, n, <span class="hljs-string">&quot; &quot;</span>);<br>                sb.append(blank(maxWidth - sb.length()));<br>                ans.add(sb.toString());<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">numWords</span> <span class="hljs-operator">=</span> right - left;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numSpaces</span> <span class="hljs-operator">=</span> maxWidth - sumlen;<br><br>            <span class="hljs-keyword">if</span>(numWords==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(words[left]);<br>                sb.append(blank(numSpaces));<br>                ans.add(sb.toString());<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 当前行不只一个单词</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">avgSpaces</span> <span class="hljs-operator">=</span> numSpaces / (numWords - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">extraSpaces</span> <span class="hljs-operator">=</span> numSpaces % (numWords - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>            sb.append(join(words, left, left + extraSpaces + <span class="hljs-number">1</span>, blank(avgSpaces + <span class="hljs-number">1</span>))); <span class="hljs-comment">// 拼接额外加一个空格的单词</span><br>            sb.append(blank(avgSpaces));<br>            sb.append(join(words, left + extraSpaces + <span class="hljs-number">1</span>, right, blank(avgSpaces))); <span class="hljs-comment">// 拼接其余单词</span><br>            ans.add(sb.toString());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// blank 返回长度为 n 的由空格组成的字符串</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">blank</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串</span><br>    <span class="hljs-keyword">public</span> StringBuffer <span class="hljs-title function_">join</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, String sep)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(words[left]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>; i &lt; right; ++i) &#123;<br>            sb.append(sep);<br>            sb.append(words[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h2><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean isPalindrome(String s) &#123;<br>      StringBuffer temp = new StringBuffer();<br><br>      int n = s.length();  <br>      for(int i=0;i&lt;n;i++)&#123;<br>          char c = s.charAt(i);<br><br>          if(Character.isLetterOrDigit(c))&#123;<br>              temp.append(Character.toLowerCase(c));<br>          &#125;<br>      &#125;<br><br>      StringBuffer rev = new StringBuffer(temp).reverse();<br><br>      return temp.toString().equals(rev.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (Character.isLetterOrDigit(ch)) &#123;<br>                temp.append(Character.toLowerCase(ch));<br>            &#125;<br>        &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temp.length();  <br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>          <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> temp.charAt(i);<br>          <span class="hljs-type">char</span> <span class="hljs-variable">ch2</span> <span class="hljs-operator">=</span> temp.charAt(j);<br>          <span class="hljs-keyword">if</span>(ch1!=ch2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          i++;<br>          j--;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>进阶：</p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p>双指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; j &lt; m)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> i == n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean isSubsequence(String s, String t) &#123;<br>        int n = s.length(), m = t.length();<br><br>        int[][] f = new int[m + 1][26];<br>        for (int i = 0; i &lt; 26; i++) &#123;<br>            f[m][i] = m;<br>        &#125;<br><br>        for (int i = m - 1; i &gt;= 0; i--) &#123;<br>            for (int j = 0; j &lt; 26; j++) &#123;<br>                if (t.charAt(i) == j + &#x27;a&#x27;)<br>                    f[i][j] = i;<br>                else<br>                    f[i][j] = f[i + 1][j];<br>            &#125;<br>        &#125;<br>        int add = 0;<br>        for (int i = 0; i &lt; n; i++) &#123;<br>            if (f[add][s.charAt(i) - &#x27;a&#x27;] == m) &#123;<br>                return false;<br>            &#125;<br>            add = f[add][s.charAt(i) - &#x27;a&#x27;] + 1;<br>        &#125;<br>        return true;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和||"></a>两数之和||</h2><p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length 。</p>
<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<p>你所设计的解决方案必须只使用常量级的额外空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int[] twoSum(int[] numbers, int target) &#123;<br>        int i = 0, j = numbers.length -1;<br>        int length = numbers.length;<br>        int[] ans = new int[2];<br>        while(i&lt;j)&#123;<br>            int temp = numbers[i] + numbers[j];<br><br>            if(temp == target)&#123;<br>                ans[0] = i+1;<br>                ans[1] = j+1;<br>                return ans;<br>            &#125;else if(temp &lt; target)&#123;<br>                i++;<br>            &#125;else&#123;<br>                j--;<br>            &#125;<br>        &#125;<br><br>        return ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int maxArea(int[] height) &#123;<br>        int i = 0, j = height.length - 1;<br>        int max = 0;<br>        while(i&lt;j)&#123;<br>            int temp = (j - i) * Math.min(height[j], height[i]);<br><br>            if(temp&gt;max)<br>                max = temp;<br>            if(height[j]&gt;=height[i])&#123;<br>                i++;<br>            &#125;else if(height[j]&lt;=height[i])&#123;<br>                j--;<br>            &#125;<br>        &#125;<br><br>        return max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


      </div>
    </div>
  </article>
  <div class="post__foot">
    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2024/01/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>网络编程</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2024/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
      </div>
      多线程&JUC
    </a>
  
</div>

    
      <div class="related-post">
  <div class="related__head">
  <a href="/tags/%E7%AE%97%E6%B3%95/" class="post-tag">#算法</a>

</div>
  <div class="realated__body">
    
      <div class="null"><div class="null-item"><div class="null-title"><a href="/2024/01/07/常用算法/" title="常用算法" rel="bookmark">常用算法</a></div></div><div class="null-item"><div class="null-title"><a href="/2024/01/15/IO流/" title="IO流" rel="bookmark">IO流</a></div></div><div class="null-item"><div class="null-title"><a href="/2024/01/15/Stream流/" title="Stream流" rel="bookmark">Stream流</a></div></div></div>
    
  </div>
</div>

    
    
  </div>

    </div>
    <div class="foot">
      <div class="foot-inner">
        <div class="foot__head">
          
            <div class="foot-line">
              
                <div class="matts">海</div>
              
                <div class="matts">内</div>
              
                <div class="matts">存</div>
              
                <div class="matts">知</div>
              
                <div class="matts">己</div>
              
            </div>
          
            <div class="foot-line">
              
                <div class="matts">天</div>
              
                <div class="matts">涯</div>
              
                <div class="matts">若</div>
              
                <div class="matts">比</div>
              
                <div class="matts">邻</div>
              
            </div>
          
        </div>
        <div class="foot__body">
          
            <div class="foot-item">
              <div class="foot-item__head">朋友</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://jtzhpf.github.io">帅哥</a>
                  </div>
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://nuistgy.github.io">kami</a>
                  </div>
                
                <div class="text">
                  <img alt="link" height="20px" width="20px" src="/images/icon/icon-link+.svg"/>
                  <a class="foot-link"
                     href="mailto:dzc2000919@gmail.com?subject=%E7%94%B3%E8%AF%B7%20Hozen.site%20%E7%9A%84%E5%8F%8B%E9%93%BE%E4%BD%8D%E7%BD%AE">
                  申请友链</a>
                </div>
              </div>
            </div>
          
          
            <div class="foot-item">
              <div class="foot-item__head">账号</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-github.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/dzc2000">dzc2000</a>
                  </div>
                
              </div>
            </div>
          
          <div class="foot-item">
            <div class="foot-item__head">联系</div>
            <div class="foot-item__body">
              <div class="text">
                <img alt="link" height="20px" width="20px" src="/images/icon/icon-email.svg"/>
                <a class="foot-link" href="mailto:dzc2000919@gmail.com">dzc2000919@gmail.com</a>
              </div>
            </div>
          </div>
        </div>
        <div class="copyright">
          <a href="http://dzc2000.github.io">饿了</a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
          <svg width="20" height="20" viewBox="0 0 725 725">
            <path fill-rule="evenodd" fill="rgb(221, 221, 221)" d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z"/>
            <path fill-rule="evenodd" fill="rgb(159, 159, 159)" d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z"/>
            <path fill-rule="evenodd" fill="rgb(0, 0, 0)" d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z"/>
          </svg>
          <a target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">致远</a>&nbsp;驱动
        </div>
      </div>
    </div>
    
    
  

  </body>
</html>