<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8"/>
    <meta name="viewport" content="initial-scale=1.0, width=device-width"/>
    <title>
      
        150题 | 饿了
      
    </title>
    <meta name="description" content=""/>
    <meta name="keywords" content=""/>
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/apple-touch-icon.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/favicon-32x32.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/favicon-16x16.png"/>
    
    
      <link rel="mask-icon"
            href="/images/logo.svg"
            color=""/>
    
    
    
      
  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/regular.ttf);
        font-weight: regular;
    }
  </style>

  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/bold.ttf);
        font-weight: bold;
    }
  </style>


    
    <link rel="stylesheet"
          type="text/css"
          href='/css/layout.css'/>
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css" />
  

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="head">
      <div class="nav">
        <a href='/' class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/logo.svg"/>
        </a>
        <input id="navBtn" type="checkbox"/>
        <div class="nav-menu">
          
            
              <a class="nav-menu-item" href="/java">技术</a>
            
              <a class="nav-menu-item" href="/paper">论文</a>
            
          
          
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner">
      <div class="post-content__head">
        <div class="post-title">150题</div>
        <div class="post-info">
          
  <a href="/tags/%E7%AE%97%E6%B3%95/" class="post-tag">#算法</a>


          <span class="post-date">2024-01-17</span>
        </div>
      </div>
      
      <div class="post-content__body">
        
          <div class="post-gallery">
            
          </div>
        
        <h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] sorted = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p1&lt;m||p2&lt;n)&#123;<br>            <span class="hljs-keyword">if</span> (p1 == m)&#123;<br>                cur = nums2[p2++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 == n)&#123;<br>                cur = nums1[p1++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[p1]&lt;nums2[p2])&#123;<br>                cur = nums1[p1++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = nums2[p2++];<br>            &#125;<br><br>            sorted[p1+p2-<span class="hljs-number">1</span>]=cur;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; nums1.length; i++)&#123;<br>            nums1[i] = sorted[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 $O(m+n)$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;<br>        int len1 = m - 1;<br>        int len2 = n - 1;<br>        int len = m + n - 1;<br>        while(len1 &gt;= 0 &amp;&amp; len2 &gt;= 0) &#123;<br>            // 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码<br>            nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];<br>        &#125;<br>        // 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1<br>        System.arraycopy(nums2, 0, nums1, 0, len2 + 1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int removeElement(int[] nums, int val) &#123;<br>        int idx = 0;<br>        for(int num : nums)&#123;<br>            if(num!=val)&#123;<br>                nums[idx++] = num;<br>            &#125;<br>        &#125;<br><br>        return idx;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="删除有序数组的重复项"><a href="#删除有序数组的重复项" class="headerlink" title="删除有序数组的重复项"></a>删除有序数组的重复项</h2><p>给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p>
<p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p>
<p>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int removeDuplicates(int[] nums) &#123;<br>        int idx = 0;<br>        for (int i=0;i&lt;nums.length - 1;i++)&#123;<br>            if(nums[i]!=nums[i+1])<br>                nums[idx++] = nums[i];<br>        &#125;<br>        nums[idx++] = nums[nums.length - 1];<br>        return idx;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>改进: 数组中没有重复元素，按照上面的方法，每次比较时 nums[p] 都不等于 nums[q]，因此就会将 q 指向的元素原地复制一遍，这个操作其实是不必要的。</p>
<p>因此我们可以添加一个小判断，当 q - p &gt; 1 时，才进行复制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public int removeDuplicates(int[] nums) &#123;<br>    if(nums == null || nums.length == 0) return 0;<br>    int p = 0;<br>    int q = 1;<br>    while(q &lt; nums.length)&#123;<br>        if(nums[p] != nums[q])&#123;<br>            if(q - p &gt; 1)&#123;<br>                nums[p + 1] = nums[q];<br>            &#125;<br>            p++;<br>        &#125;<br>        q++;<br>    &#125;<br>    return p + 1;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="删除有序数组的重复项2"><a href="#删除有序数组的重复项2" class="headerlink" title="删除有序数组的重复项2"></a>删除有序数组的重复项2</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int removeDuplicates(int[] nums) &#123;<br>        int idx = 0;<br><br>        for(int i=idx+2; i&lt;nums.length;i++)&#123;<br>            if(nums[idx] != nums[i])&#123;<br>                nums[idx+2] = nums[i];<br>                idx++;<br>            &#125;<br>        &#125;<br><br>        return idx+2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>计数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int removeDuplicates(int[] nums) &#123;<br>        int left=0,right=0,n=nums.length;<br>        int preNum = nums[0],cnt=0;<br>        while(right&lt;n)&#123;<br>            if(nums[right]==preNum)&#123;<br>                cnt++;<br>                if(cnt&gt;2)&#123;<br>                    right++;<br>                    continue;<br>                &#125;<br>            &#125;else&#123;<br>                preNum = nums[right];<br>                cnt=1;<br>            &#125;<br>            nums[left++]=nums[right++];<br>        &#125;<br>        return left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int majorityElement(int[] nums) &#123;<br>        Map&lt;Integer, Integer&gt; mp = new HashMap&lt;Integer, Integer&gt;();<br><br>        for(int i = 0; i&lt;nums.length;i++)&#123;<br>            if(mp.get(nums[i])==null)&#123;<br>                mp.put(nums[i], 1);<br>            &#125;else&#123;<br>                int temp = mp.get(nums[i]) + 1;<br>                mp.put(nums[i], temp);<br>            &#125;<br>        &#125;<br><br>        for(Map.Entry&lt;Integer, Integer&gt; entry: mp.entrySet())&#123;<br>            if(entry.getValue()&gt;(nums.length/2))&#123;<br>                return entry.getKey();<br>            &#125;<br>        &#125;<br><br>        return 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int majorityElement(int[] nums) &#123;<br>        Arrays.sort(nums);<br>        return nums[nums.length / 2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public void rotate(int[] nums, int k) &#123;<br>        int[] temp = new int[nums.length];<br>        for(int i=0;i&lt;nums.length;i++)&#123;<br>            temp[(i+k)%nums.length] = nums[i];<br>        &#125;<br><br>        System.arraycopy(temp, 0, nums, 0, nums.length);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="环状替换"><a href="#环状替换" class="headerlink" title="环状替换"></a>环状替换</h3><p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/images/202401181212652.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public void rotate(int[] nums, int k) &#123;<br>        int n = nums.length;<br>        k = k % n;<br>        int count = gcd(k, n);<br>        for (int start = 0; start &lt; count; ++start) &#123;<br>            int current = start;<br>            int prev = nums[start];<br>            do &#123;<br>                int next = (current + k) % n;<br>                int temp = nums[next];<br>                nums[next] = prev;<br>                prev = temp;<br>                current = next;<br>            &#125; while (start != current);<br>        &#125;<br>    &#125;<br><br>    public int gcd(int x, int y) &#123;<br>        return y &gt; 0 ? gcd(y, x % y) : x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public void rotate(int[] nums, int k) &#123;<br>        reverse(nums, 0, nums.length-1);<br>        reverse(nums, 0, k-1);<br>        reverse(nums,k,nums.length-1);<br><br>    &#125;<br><br>    public void reverse(int[] nums, int start, int end)&#123;<br>        while(start&lt;end)&#123;<br>            int temp = nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = temp;<br><br>            start++;<br>            end--;<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int maxProfit(int[] prices) &#123;<br>        int count = 0;<br>        int min = 10000;<br>        for(int i=0; i&lt;prices.length; i++)&#123;<br>            if(prices[i]&lt;min)<br>                min = prices[i];<br>            if(count&lt;(prices[i]-min))<br>                count = prices[i]-min;<br><br>        &#125;<br><br>        return count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机2"><a href="#买卖股票的最佳时机2" class="headerlink" title="买卖股票的最佳时机2"></a>买卖股票的最佳时机2</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p>贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int maxProfit(int[] prices) &#123;<br>        int count = 0;<br>        for(int i=0; i&lt;prices.length-1;i++)&#123;<br>            if(prices[i+1]&gt;prices[i])&#123;<br>                count += prices[i+1] - prices[i];<br>            &#125;<br>        &#125;<br><br>        return count;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>动态规划</p>
<p>第 1 步：定义状态</p>
<p>状态 dp[i][j] 定义如下：</p>
<p>dp[i][j] 表示到下标为 i 的这一天，持股状态为 j 时，我们手上拥有的最大现金数。</p>
<p>注意：限定持股状态为 j 是为了方便推导状态转移方程，这样的做法满足 无后效性。</p>
<p>其中：</p>
<p>第一维 i 表示下标为 i 的那一天（ 具有前缀性质，即考虑了之前天数的交易 ）；<br>第二维 j 表示下标为 i 的那一天是持有股票，还是持有现金。这里 0 表示持有现金（cash），1 表示持有股票（stock）。<br>第 2 步：思考状态转移方程</p>
<p>状态从持有现金（cash）开始，到最后一天我们关心的状态依然是持有现金（cash）；<br>每一天状态可以转移，也可以不动。</p>
<p>说明：</p>
<p>由于不限制交易次数，除了最后一天，每一天的状态可能不变化，也可能转移；<br>写代码的时候，可以不用对最后一天单独处理，输出最后一天，状态为 0 的时候的值即可。<br>第 3 步：确定初始值</p>
<p>起始的时候：</p>
<p>如果什么都不做，dp[0][0] &#x3D; 0；<br>如果持有股票，当前拥有的现金数是当天股价的相反数，即 dp[0][1] &#x3D; -prices[i]；<br>第 4 步：确定输出值</p>
<p>终止的时候，上面也分析了，输出 dp[len - 1][0]，因为一定有 dp[len - 1][0] &gt; dp[len - 1][1]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Solution &#123;<br><br>    public int maxProfit(int[] prices) &#123;<br>        int len = prices.length;<br>        if (len &lt; 2) &#123;<br>            return 0;<br>        &#125;<br><br>        // 0：持有现金<br>        // 1：持有股票<br>        // 状态转移：0 → 1 → 0 → 1 → 0 → 1 → 0<br>        int[][] dp = new int[len][2];<br><br>        dp[0][0] = 0;<br>        dp[0][1] = -prices[0];<br><br>        for (int i = 1; i &lt; len; i++) &#123;<br>            // 这两行调换顺序也是可以的<br>            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);<br>            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);<br>        &#125;<br>        return dp[len - 1][0];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean canJump(int[] nums) &#123;<br>        int k = 0;<br>        for(int i=0;i&lt;nums.length;i++)&#123;<br>            if(i&gt;k) return false;<br>            k = Math.max(k, i+nums[i]);<br>        &#125;<br><br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h2><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>
<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。返回到达 nums[n - 1] 的最小跳跃次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int jump(int[] nums) &#123;<br>        int ans = 0;<br>        int end = 1;<br>        int k = 0;<br><br>        for(int i=0;i&lt;nums.length;i++)&#123;<br>            k = Math.max(k, i+nums[i]);<br>            if(i == end)&#123;<br>                end = k;<br>                ans++;<br>            &#125;<br>        &#125;<br><br>        return ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int jump(int[] nums) &#123;<br>        int ans = 0;<br>        int end = 0;<br>        int begin = 0;<br><br>        while(end&lt;nums.length-1)&#123;<br>            int temp = 0;<br><br>            for(int i = begin; i&lt;=end; i++)&#123;<br>                temp = Math.max(i+nums[i], temp);<br>            &#125;<br><br>            begin = end + 1;<br>            end = temp;<br>            ans++;<br>        &#125;<br><br>        return ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="H指数"><a href="#H指数" class="headerlink" title="H指数"></a>H指数</h2><p>给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。</p>
<p>根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int hIndex(int[] citations) &#123;<br>        Arrays.sort(citations);<br>        int h = 0, i = citations.length - 1;<br>        while(i&gt;= 0 &amp;&amp; citations[i]&gt;h)&#123;<br>            h++;<br>            i--;<br>        &#125;<br><br>        return h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>计数排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Solution &#123;<br>    public int hIndex(int[] citations) &#123;<br>        int n = citations.length, tot = 0;<br>        int[] counter = new int[n + 1];<br>        for (int i = 0; i &lt; n; i++) &#123;<br>            if (citations[i] &gt;= n) &#123;<br>                counter[n]++;<br>            &#125; else &#123;<br>                counter[citations[i]]++;<br>            &#125;<br>        &#125;<br>        for (int i = n; i &gt;= 0; i--) &#123;<br>            tot += counter[i];<br>            if (tot &gt;= i) &#123;<br>                return i;<br>            &#125;<br>        &#125;<br>        return 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>二分查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int hIndex(int[] citations) &#123;<br>        int left = 0,right = citations.length;<br>        int count = 0, mid = 0;<br><br>        while(left&lt;right)&#123;<br>            mid = (left+right+1)&gt;&gt;1;<br><br>            count = 0;<br>            for(int i =0; i&lt; citations.length;i++)&#123;<br>                if(citations[i]&gt;=mid)<br>                    count++;<br>            &#125;<br><br>            if(count&gt;=mid)<br>                left = mid;<br>            else<br>                right = mid -1;<br>            <br>        &#125;<br>        return left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="O-1-时间插入，删除和获取随机元素"><a href="#O-1-时间插入，删除和获取随机元素" class="headerlink" title="O(1)时间插入，删除和获取随机元素"></a>O(1)时间插入，删除和获取随机元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class RandomizedSet &#123;<br>    Random rd;<br>    Map&lt;Integer, Integer&gt; mp;<br>    int idx;<br>    static int[] nums = new int[200010];<br><br>    public RandomizedSet() &#123;<br>        rd = new Random();<br>        mp = new HashMap();<br>        idx = -1;<br>    &#125;<br>    <br>    public boolean insert(int val) &#123;<br>        if(!mp.containsKey(val))&#123;<br>            nums[++idx] = val;<br>            mp.put(val, idx);<br>            return true;<br>        &#125;else&#123;<br>            return false;<br>        &#125;<br>            <br>    &#125;<br>    <br>    public boolean remove(int val) &#123;<br>        if(mp.containsKey(val))&#123;<br>            int loc = mp.remove(val);<br>            if(loc != idx) mp.put(nums[idx], loc);<br>            nums[loc] = nums[idx--];<br>            return true;<br>        &#125;else&#123;<br>            return false;<br>        &#125;<br>    &#125;<br>    <br>    public int getRandom() &#123;<br>        return nums[rd.nextInt(idx + 1)];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="出自身以外元素的乘积"><a href="#出自身以外元素的乘积" class="headerlink" title="出自身以外元素的乘积"></a>出自身以外元素的乘积</h2><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p>
<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p>
<p>请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int[] productExceptSelf(int[] nums) &#123;<br>        int[] answer = new int[nums.length];<br><br>        int[] left = new int[nums.length];<br>        int[] right = new int[nums.length];<br><br>        left[0] = 1;<br>        for(int i=1; i&lt;nums.length; i++)&#123;<br>            left[i] = left[i - 1] * nums[i -1];<br>        &#125;<br><br>        right[nums.length - 1] = 1;<br><br>        for(int i=nums.length -2;i&gt;=0;i--)&#123;<br>            right[i] = right[i+1]*nums[i+1];<br>        &#125;<br><br>        for(int i = 0;i&lt;nums.length;i++)&#123;<br>            answer[i] = left[i] * right[i];<br>        &#125;<br><br>        return answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>改进</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int[] productExceptSelf(int[] nums) &#123;<br>        int length = nums.length;<br>        int[] answer = new int[length];<br><br>        // answer[i] 表示索引 i 左侧所有元素的乘积<br>        // 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 answer[0] = 1<br>        answer[0] = 1;<br>        for (int i = 1; i &lt; length; i++) &#123;<br>            answer[i] = nums[i - 1] * answer[i - 1];<br>        &#125;<br><br>        // R 为右侧所有元素的乘积<br>        // 刚开始右边没有元素，所以 R = 1<br>        int R = 1;<br>        for (int i = length - 1; i &gt;= 0; i--) &#123;<br>            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R<br>            answer[i] = answer[i] * R;<br>            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上<br>            R *= nums[i];<br>        &#125;<br>        return answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int canCompleteCircuit(int[] gas, int[] cost) &#123;<br>        int n = gas.length;<br>        int i = 0;<br><br>        while(i&lt;n)&#123;<br>            int sum_g = 0,sum_c = 0;<br>            int count = 0;<br><br>            while(count &lt; n)&#123;<br>                int j = (i+count)%n;<br>                sum_g += gas[j];<br>                sum_c += cost[j];<br><br>                if(sum_g&lt;sum_c)<br>                    break;<br><br>                count++;<br>            &#125;<br><br>            if(count == n)&#123;<br>                return i;<br>            &#125;else&#123;<br>                i = i + count + 1;<br>            &#125;<br><br><br>        &#125;<br><br>        return -1;<br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>class Solution &#123;<br>    public int candy(int[] ratings) &#123;<br>        int n = ratings.length;<br>        int[] left = new int[n];<br><br>        for(int i=0;i&lt;n;i++)&#123;<br>            if(i&gt;0 &amp;&amp; ratings[i]&gt;ratings[i-1])&#123;<br>                left[i] = left[i-1]+1;<br>            &#125;else&#123;<br>                left[i] = 1;<br>            &#125;<br>        &#125;<br><br>        int right = 0, count = 0;<br><br>        for(int i = n-1; i&gt;=0; i--)&#123;<br>            if(i&lt;n-1 &amp;&amp; ratings[i]&gt;ratings[i+1])&#123;<br>                right++;<br>            &#125;else&#123;<br>                right = 1;<br>            &#125;<br><br>            count += Math.max(left[i], right);<br>        &#125;<br><br>        return count;<br>    &#125;<br><br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>




<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>按行来（超时）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int n = height.length;<br>        int m = getMax(height);<br>        int sum = 0;<br>        for(int i=1;i&lt;=m;i++)&#123;<br>            boolean isStart = false;<br>            int temp = 0;<br>            for(int j = 0; j&lt;n; j++)&#123;<br>                if(isStart &amp;&amp; height[j]&lt;i)&#123;<br>                    temp++;<br>                &#125;<br>                if(height[j]&gt;=i)&#123;<br>                    sum = sum + temp;<br>                    temp = 0;<br><br>                    isStart = true;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        return sum;<br>    &#125;<br><br>    public int getMax(int[] height)&#123;<br>        int max = 0;<br>        for(int i=0; i&lt;height.length;i++)&#123;<br>            if(max&lt;height[i])<br>                max = height[i];<br>        &#125;<br>        <br>        return max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>按列算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int sum = 0;<br>        for(int i= 1;i&lt;height.length-1;i++)&#123;<br>            int max_left = 0;<br>            for(int j = i - 1;j&gt;=0;j--)&#123;<br>                if(height[j]&gt;max_left)<br>                    max_left = height[j];<br>            &#125;<br><br>            int max_right = 0;<br><br>            for(int j=i+1;j&lt;height.length;j++)&#123;<br>                if(height[j]&gt;max_right)<br>                    max_right = height[j];<br>            &#125;<br><br>            int min = Math.min(max_left, max_right);<br><br>            if(min&gt;height[i])&#123;<br>                sum += (min - height[i]);<br>            &#125;<br>        &#125;<br><br>        return sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int sum = 0;<br><br>        int[] max_left = new int[height.length];<br>        int[] max_right = new int[height.length];<br><br>        for(int i =1;i&lt;height.length-1;i++)&#123;<br>            max_left[i]= Math.max(max_left[i-1], height[i-1]);<br>        &#125;<br><br>        for(int i = height.length - 2; i&gt;=0;i--)&#123;<br>            max_right[i] = Math.max(max_right[i+1], height[i+1]);<br>        &#125;<br><br>        for(int i=1;i&lt;height.length-1;i++)&#123;<br>            int min = Math.min(max_left[i], max_right[i]);<br>            if(min&gt;height[i])&#123;<br>                sum += (min - height[i]);<br>            &#125;<br>        &#125;<br><br>        return sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int sum = 0;<br>        int max_left = 0;<br>        int[] max_right = new int[height.length];<br>        for (int i = height.length - 2; i &gt;= 0; i--) &#123;<br>            max_right[i] = Math.max(max_right[i + 1], height[i + 1]);<br>        &#125;<br>        for (int i = 1; i &lt; height.length - 1; i++) &#123;<br>            max_left = Math.max(max_left, height[i - 1]);<br>            int min = Math.min(max_left, max_right[i]);<br>            if (min &gt; height[i]) &#123;<br>                sum = sum + (min - height[i]);<br>            &#125;<br>        &#125;<br>        return sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int romanToInt(String s) &#123;<br>        char[] chars = s.toCharArray();<br>        int[] ints = new int[chars.length];<br>        for (int i = 0; i &lt; chars.length; i++) &#123;<br>            ints[i] = getValue(chars[i]);<br>        &#125;<br>        int sum = 0;<br>        for (int i = 0; i &lt; ints.length; i++) &#123;<br>            if (i &lt; ints.length - 1 &amp;&amp; ints[i] &lt; ints[i + 1]) &#123;<br>                ints[i] *= -1;<br>            &#125;<br>            sum += ints[i];<br>        &#125;<br>        return sum;<br>    &#125;<br><br>    private int getValue(char romanChar) &#123;<br>        switch (romanChar) &#123;<br>            case &#x27;I&#x27; -&gt; &#123;<br>                return 1;<br>            &#125;<br>            case &#x27;V&#x27; -&gt; &#123;<br>                return 5;<br>            &#125;<br>            case &#x27;X&#x27; -&gt; &#123;<br>                return 10;<br>            &#125;<br>            case &#x27;L&#x27; -&gt; &#123;<br>                return 50;<br>            &#125;<br>            case &#x27;C&#x27; -&gt; &#123;<br>                return 100;<br>            &#125;<br>            case &#x27;D&#x27; -&gt; &#123;<br>                return 500;<br>            &#125;<br>            case &#x27;M&#x27; -&gt; &#123;<br>                return 1000;<br>            &#125;<br>            default -&gt; &#123;<br>                return 0;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给你一个整数，将其转为罗马数字。</p>
<p>模拟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;<br>    String[] symbols = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;<br><br>    public String intToRoman(int num) &#123;<br>        StringBuffer roman = new StringBuffer();<br><br>        for(int i=0;i&lt;values.length;i++)&#123;<br>            int value = values[i];<br>            String symbol = symbols[i];<br><br>            while(num&gt;=value)&#123;<br>                num -= value;<br>                roman.append(symbol);<br>            &#125;<br>            if(num == 0)&#123;<br>                break;<br>            &#125;<br>        &#125;<br><br>        return roman.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>硬编码</p>
<p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/images/202401241339638.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    String[] thousands = &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;;<br>    String[] hundreds  = &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;;<br>    String[] tens      = &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;;<br>    String[] ones      = &#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;;<br><br>    public String intToRoman(int num) &#123;<br>        StringBuffer roman = new StringBuffer();<br>        roman.append(thousands[num / 1000]);<br>        roman.append(hundreds[num % 1000 / 100]);<br>        roman.append(tens[num % 100 / 10]);<br>        roman.append(ones[num % 10]);<br>        return roman.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h2><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p>
<p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int lengthOfLastWord(String s) &#123;<br>        int end = s.length() - 1;<br>        while(end&gt;=0&amp;&amp; s.charAt(end) == &#x27; &#x27;) end--;<br>        if(end&lt;0) return 0;<br>        int start = end;<br>        while(start&gt;=0 &amp;&amp; s.charAt(start)!= &#x27; &#x27;) start--;<br>        return end-start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p>横向扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String longestCommonPrefix(String[] strs) &#123;<br>        if(strs == null || strs.length == 0)<br>            return &quot;&quot;;<br><br>        String pre = strs[0];<br>        for(int i=1;i&lt;strs.length;i++)&#123;<br>            pre = common(pre, strs[i]);<br>            if(pre.length()==0)<br>                break;<br>        &#125;<br><br>        return pre;<br>    &#125;<br><br>    public String common(String str1, String str2)&#123;<br>        int length = Math.min(str1.length(), str2.length());<br><br>        int index = 0;<br>        while(index&lt;length&amp;&amp;str1.charAt(index) == str2.charAt(index))<br>            index++;<br>        <br>        return str1.substring(0, index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>纵向扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String longestCommonPrefix(String[] strs) &#123;<br>        if (strs == null || strs.length == 0) &#123;<br>            return &quot;&quot;;<br>        &#125;<br><br>        int length = strs[0].length();<br>        int count = strs.length;<br><br>        for(int i=0; i&lt;length;i++)&#123;<br>            char c = strs[0].charAt(i);<br>            for(int j = 1;j&lt;count;j++)&#123;<br>                if(i == strs[j].length()||strs[j].charAt(i)!=c)<br>                    return strs[0].substring(0, i);<br>            &#125;<br>        &#125;<br><br>        return strs[0];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h2><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String reverseWords(String s) &#123;<br>        s = s.trim();<br>        int length = s.length() ;<br>        StringBuilder ans = new StringBuilder();<br><br>        for(int i = length -1;i&gt;=0;i--)&#123;<br>             while(i&gt;=0 &amp;&amp; s.charAt(i) ==&#x27; &#x27;)&#123;<br>                --i;<br>            &#125;<br>            int end = i;<br>            if(i&lt;0)&#123;<br>                break;<br>            &#125;<br><br>            while(i&gt;=0 &amp;&amp; s.charAt(i)!=&#x27; &#x27;)&#123;<br>                i--;<br>            &#125;<br><br>            ans.append(&quot; &quot;).append(s.substring(i+1, end+1));<br>        &#125;<br><br>        return ans.toString().trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p>
<p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String convert(String s, int numRows) &#123;<br>        int n = s.length(), r = numRows;<br>        if (r == 1 || r &gt;= n) &#123;<br>            return s;<br>        &#125;<br>        int t = r*2 - 2;<br>        int c = (n+t-1)/t * (r-1);<br><br><br>        char[][] mat = new char[r][c];<br><br>        for(int i=0, x=0, y=0;i&lt;s.length();i++)&#123;<br>            mat[x][y] = s.charAt(i);<br>            if(i%t&lt;r-1)&#123;<br>                ++x;<br>            &#125;else&#123;<br>                --x;<br>                ++y;<br>            &#125;<br>        &#125;<br><br>        StringBuffer ans = new StringBuffer();<br>        for(char[] row: mat)&#123;<br>            for(char ch: row)&#123;<br>                if(ch!=0)&#123;<br>                    ans.append(ch);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        return ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>flag </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String convert(String s, int numRows) &#123;<br>        if(numRows&lt;2) return s;<br>        List&lt;StringBuffer&gt; rows = new ArrayList&lt;StringBuffer&gt;();<br><br>        for(int i=0;i&lt;numRows;i++) rows.add(new StringBuffer());<br><br>        int i=0, flag = -1;<br><br>        for(char c:s.toCharArray())&#123;<br>            rows.get(i).append(c);<br><br>            if(i == 0 || i == numRows - 1) flag = -flag;<br><br>            i+= flag;<br>        &#125;<br>        StringBuffer res = new StringBuffer();<br>        for(StringBuffer row : rows) res.append(row);<br><br>        return res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="找出字符串中第一个匹配的下标"><a href="#找出字符串中第一个匹配的下标" class="headerlink" title="找出字符串中第一个匹配的下标"></a>找出字符串中第一个匹配的下标</h2><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int strStr(String haystack, String needle) &#123;<br>        int n = needle.length();<br>        int length  = haystack.length();<br>        int ans = -1;<br>        for(int i=0;i&lt;=length - n;i++)&#123;<br>            String temp = haystack.substring(i, i+n);<br><br>            if(equals(temp, needle))&#123;<br>                ans = i;<br>                break;<br>            &#125;<br>        &#125;<br><br>        return ans;<br>    &#125;<br><br>    public boolean equals(String s_1, String s_2)&#123;<br>        char[] s1 = s_1.toCharArray(), s2 = s_2.toCharArray();<br>        int n = s_1.length(), m = s_2.length();<br>        if(n!=m)<br>            return false;<br>        for(int i=0;i&lt;n;i++)&#123;<br>            if(s1[i]!=s2[i])<br>                return false;<br>        &#125;<br><br>        return true;<br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>KMP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    // KMP 算法<br>    // ss: 原串(string)  pp: 匹配串(pattern)<br>    public int strStr(String ss, String pp) &#123;<br>        if (pp.isEmpty()) return 0;<br>        <br>        // 分别读取原串和匹配串的长度<br>        int n = ss.length(), m = pp.length();<br>        // 原串和匹配串前面都加空格，使其下标从 1 开始<br>        ss = &quot; &quot; + ss;<br>        pp = &quot; &quot; + pp;<br><br>        char[] s = ss.toCharArray();<br>        char[] p = pp.toCharArray();<br><br>        // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）<br>        int[] next = new int[m + 1];<br>        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】<br>        for (int i = 2, j = 0; i &lt;= m; i++) &#123;<br>            // 匹配不成功的话，j = next(j)<br>            while (j &gt; 0 &amp;&amp; p[i] != p[j + 1]) j = next[j];<br>            // 匹配成功的话，先让 j++<br>            if (p[i] == p[j + 1]) j++;<br>            // 更新 next[i]，结束本次循环，i++<br>            next[i] = j;<br>        &#125;<br><br>        // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】<br>        for (int i = 1, j = 0; i &lt;= n; i++) &#123;<br>            // 匹配不成功 j = next(j)<br>            while (j &gt; 0 &amp;&amp; s[i] != p[j + 1]) j = next[j];<br>            // 匹配成功的话，先让 j++，结束本次循环后 i++<br>            if (s[i] == p[j + 1]) j++;<br>            // 整一段匹配成功，直接返回下标<br>            if (j == m) return i - m;<br>        &#125;<br><br>        return -1;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="文本左右对齐"><a href="#文本左右对齐" class="headerlink" title="文本左右对齐"></a>文本左右对齐</h2><p>给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p>
<p>你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ‘ ‘ 填充，使得每行恰好有 maxWidth 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">fullJustify</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> maxWidth)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = words.length;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> right;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sumlen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(right&lt;n &amp;&amp; sumlen + words[right].length() + right - left &lt;= maxWidth)&#123;<br>                sumlen += words[right++].length();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(right == n)&#123;<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> join(words, left, n, <span class="hljs-string">&quot; &quot;</span>);<br>                sb.append(blank(maxWidth - sb.length()));<br>                ans.add(sb.toString());<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">numWords</span> <span class="hljs-operator">=</span> right - left;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numSpaces</span> <span class="hljs-operator">=</span> maxWidth - sumlen;<br><br>            <span class="hljs-keyword">if</span>(numWords==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(words[left]);<br>                sb.append(blank(numSpaces));<br>                ans.add(sb.toString());<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 当前行不只一个单词</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">avgSpaces</span> <span class="hljs-operator">=</span> numSpaces / (numWords - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">extraSpaces</span> <span class="hljs-operator">=</span> numSpaces % (numWords - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>            sb.append(join(words, left, left + extraSpaces + <span class="hljs-number">1</span>, blank(avgSpaces + <span class="hljs-number">1</span>))); <span class="hljs-comment">// 拼接额外加一个空格的单词</span><br>            sb.append(blank(avgSpaces));<br>            sb.append(join(words, left + extraSpaces + <span class="hljs-number">1</span>, right, blank(avgSpaces))); <span class="hljs-comment">// 拼接其余单词</span><br>            ans.add(sb.toString());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// blank 返回长度为 n 的由空格组成的字符串</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">blank</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串</span><br>    <span class="hljs-keyword">public</span> StringBuffer <span class="hljs-title function_">join</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, String sep)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(words[left]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>; i &lt; right; ++i) &#123;<br>            sb.append(sep);<br>            sb.append(words[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h2><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean isPalindrome(String s) &#123;<br>      StringBuffer temp = new StringBuffer();<br><br>      int n = s.length();  <br>      for(int i=0;i&lt;n;i++)&#123;<br>          char c = s.charAt(i);<br><br>          if(Character.isLetterOrDigit(c))&#123;<br>              temp.append(Character.toLowerCase(c));<br>          &#125;<br>      &#125;<br><br>      StringBuffer rev = new StringBuffer(temp).reverse();<br><br>      return temp.toString().equals(rev.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (Character.isLetterOrDigit(ch)) &#123;<br>                temp.append(Character.toLowerCase(ch));<br>            &#125;<br>        &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temp.length();  <br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>          <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> temp.charAt(i);<br>          <span class="hljs-type">char</span> <span class="hljs-variable">ch2</span> <span class="hljs-operator">=</span> temp.charAt(j);<br>          <span class="hljs-keyword">if</span>(ch1!=ch2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          i++;<br>          j--;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>进阶：</p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p>双指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; j &lt; m)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> i == n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean isSubsequence(String s, String t) &#123;<br>        int n = s.length(), m = t.length();<br><br>        int[][] f = new int[m + 1][26];<br>        for (int i = 0; i &lt; 26; i++) &#123;<br>            f[m][i] = m;<br>        &#125;<br><br>        for (int i = m - 1; i &gt;= 0; i--) &#123;<br>            for (int j = 0; j &lt; 26; j++) &#123;<br>                if (t.charAt(i) == j + &#x27;a&#x27;)<br>                    f[i][j] = i;<br>                else<br>                    f[i][j] = f[i + 1][j];<br>            &#125;<br>        &#125;<br>        int add = 0;<br>        for (int i = 0; i &lt; n; i++) &#123;<br>            if (f[add][s.charAt(i) - &#x27;a&#x27;] == m) &#123;<br>                return false;<br>            &#125;<br>            add = f[add][s.charAt(i) - &#x27;a&#x27;] + 1;<br>        &#125;<br>        return true;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和||"></a>两数之和||</h2><p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length 。</p>
<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<p>你所设计的解决方案必须只使用常量级的额外空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int[] twoSum(int[] numbers, int target) &#123;<br>        int i = 0, j = numbers.length -1;<br>        int length = numbers.length;<br>        int[] ans = new int[2];<br>        while(i&lt;j)&#123;<br>            int temp = numbers[i] + numbers[j];<br><br>            if(temp == target)&#123;<br>                ans[0] = i+1;<br>                ans[1] = j+1;<br>                return ans;<br>            &#125;else if(temp &lt; target)&#123;<br>                i++;<br>            &#125;else&#123;<br>                j--;<br>            &#125;<br>        &#125;<br><br>        return ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int maxArea(int[] height) &#123;<br>        int i = 0, j = height.length - 1;<br>        int max = 0;<br>        while(i&lt;j)&#123;<br>            int temp = (j - i) * Math.min(height[j], height[i]);<br><br>            if(temp&gt;max)<br>                max = temp;<br>            if(height[j]&gt;=height[i])&#123;<br>                i++;<br>            &#125;else if(height[j]&lt;=height[i])&#123;<br>                j--;<br>            &#125;<br>        &#125;<br><br>        return max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span>||len&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>)&#123;<br>                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));<br><br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l+<span class="hljs-number">1</span>]) &#123;<br>                        l++;<br>                    &#125;<br>                    <br>                    <span class="hljs-keyword">while</span>(l&lt; r &amp;&amp; nums[r] == nums[r-<span class="hljs-number">1</span>])&#123;<br>                        r--;<br>                    &#125; <br><br>                    l++;<br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>暴力法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;j&lt;len;j++)&#123;<br>                temp += nums[j];<br>                <span class="hljs-keyword">if</span>(temp&gt;=target)&#123;<br>                    ans = Math.min(ans, j-i+<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans == Integer.MAX_VALUE?<span class="hljs-number">0</span>:ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前缀和+二分查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br><br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>            sum[i] =sum[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> target + sum[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> Arrays.binarySearch(sum, temp);<br>            <span class="hljs-keyword">if</span>(bound&lt;<span class="hljs-number">0</span>)&#123;<br>                bound = -bound - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(bound&lt;=len)&#123;<br>                ans = Math.min(ans, bound-(i-<span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans == Integer.MAX_VALUE?<span class="hljs-number">0</span>:ans;<br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>滑动窗口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(end&lt;n)&#123;<br>            sum += nums[end];<br>            <span class="hljs-keyword">while</span>(sum&gt;=target)&#123;<br>                sum -= nums[start];<br>                ans = Math.min(ans, end-start+<span class="hljs-number">1</span>);<br>                start++;<br>            &#125;<br><br>            end++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(mp.containsKey(s.charAt(i)))&#123;<br>                pre = Math.max(pre,mp.get(s.charAt(i)) + <span class="hljs-number">1</span>);<br>            &#125;<br>            mp.put(s.charAt(i), i);<br>            ans = Math.max(ans, i-pre+<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a>串联所有单词的子串</h2><p>给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。</p>
<p> s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。</p>
<p>例如，如果 words &#x3D; [“ab”,”cd”,”ef”]， 那么 “abcdef”， “abefcd”，”cdabef”， “cdefab”，”efabcd”， 和 “efcdab” 都是串联子串。 “acdbef” 不是串联子串，因为他不是任何 words 排列的连接。<br>返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findSubstring</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//所有单词的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> words.length;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wordLen</span> <span class="hljs-operator">=</span> words[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stringLen</span> <span class="hljs-operator">=</span> s.length();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;wordLen;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i+num*wordLen&gt;stringLen)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            Map&lt;String, Integer&gt; differ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;num;j++)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> s.substring(i+j*wordLen, i+(j+<span class="hljs-number">1</span>)*wordLen);<br>                differ.put(word, differ.getOrDefault(word, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(String word: words)&#123;<br>                differ.put(word, differ.getOrDefault(word, <span class="hljs-number">0</span>) -<span class="hljs-number">1</span>);<br><br>                <span class="hljs-keyword">if</span>(differ.get(word) == <span class="hljs-number">0</span>)&#123;<br>                    differ.remove(word);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> i;start&lt;stringLen - num * wordLen+<span class="hljs-number">1</span>; start += wordLen)&#123;<br>                <span class="hljs-keyword">if</span>(start != i)&#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> s.substring(start + (num - <span class="hljs-number">1</span>) * wordLen, start + num * wordLen);<br>                    differ.put(word, differ.getOrDefault(word, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span>(differ.get(word)==<span class="hljs-number">0</span>)&#123;<br>                        differ.remove(word);<br>                    &#125;<br><br>                    word = s.substring(start - wordLen, start);<br>                    differ.put(word, differ.getOrDefault(word, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br><br>                    <span class="hljs-keyword">if</span>(differ.get(word) == <span class="hljs-number">0</span>)&#123;<br>                        differ.remove(word);<br>                    &#125;<br>                    word = s.substring(start-wordLen, start);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(differ.isEmpty())&#123;<br>                    res.add(start);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>##最小覆盖子串</p>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：</p>
<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    Map&lt;Character, Integer&gt; ori = new HashMap&lt;Character, Integer&gt;();<br>    Map&lt;Character, Integer&gt; cnt = new HashMap&lt;Character, Integer&gt;();<br><br>    public String minWindow(String s, String t) &#123;<br>        int tLen = t.length();<br>        for(int i = 0;i&lt;tLen;i++)&#123;<br>            char c = t.charAt(i);<br>            ori.put(c, ori.getOrDefault(c, 0)+1);<br>        &#125;<br><br>        int l = 0, r=-1;<br>        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;<br>        int sLen = s.length();<br>        while(r&lt;sLen)&#123;<br>            ++r;<br><br>            if(r&lt;sLen &amp;&amp; ori.containsKey(s.charAt(r)))&#123;<br>                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);<br>            &#125;<br>            while(check() &amp;&amp; l&lt;= r)&#123;<br>                if(r-l+1&lt;len)&#123;<br>                    len = r - l + 1;<br>                    ansL = l;<br>                    ansR = l + len;<br>                &#125;<br>                if(ori.containsKey(s.charAt(l)))&#123;<br>                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);<br>                &#125;<br>                ++l;<br>            &#125;<br>        &#125;<br><br>        return ansL == -1 ? &quot;&quot; : s.substring(ansL, ansR);<br><br>    &#125;<br><br>    public boolean check() &#123;<br>        Iterator iter = ori.entrySet().iterator(); <br>        while (iter.hasNext()) &#123; <br>            Map.Entry entry = (Map.Entry) iter.next(); <br>            Character key = (Character) entry.getKey(); <br>            Integer val = (Integer) entry.getValue(); <br>            if (cnt.getOrDefault(key, 0) &lt; val) &#123;<br>                return false;<br>            &#125;<br>        &#125; <br>        return true;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h2><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean isValidSudoku(char[][] board) &#123;<br>        int size = 9;<br>        int[] rows = new int[size];<br>        int[] columns = new int[size];<br>        int[] boxs = new int[size];<br><br>        for(int i=0;i&lt;size;i++)&#123;<br>            for(int j=0;j&lt;size;j++)&#123;<br>                char val = board[i][j];<br><br>                if(val!=&#x27;.&#x27;)&#123;<br>                    int index = 1&lt;&lt;(val-&#x27;0&#x27;);<br>                    int boxNum = (i/3)*3+j/3;<br>                    if((rows[i] &amp; index) != 0 || (columns[j] &amp; index) != 0 || (boxs[boxNum] &amp; index) != 0)&#123;<br>                        return false;<br>                    &#125;<br>                    rows[i] |= index;<br>                    columns[j] |= index;<br>                    boxs[boxNum] |= index;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>解法一：（顺序合并）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode next;<br> *     ListNode() &#123;&#125;<br> *     ListNode(int val) &#123; this.val = val; &#125;<br> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public ListNode mergeKLists(ListNode[] lists) &#123;<br>        int n = lists.length;<br>        ListNode ans = null;<br>        for(int i=0;i&lt;n;i++)&#123;<br>            ans = mergeTwoLists(ans, lists[i]);<br>        &#125;<br><br>        return ans;<br>    &#125;<br><br>    public ListNode mergeTwoLists(ListNode a, ListNode b)&#123;<br>        if(a==null||b==null)&#123;<br>            return a!=null?a:b;<br>        &#125;<br><br>        ListNode head = new ListNode(0);<br>        ListNode tail = head, aPtr = a, bPtr = b;<br><br>        while(aPtr!=null&amp;&amp;bPtr!=null)&#123;<br>            if(aPtr.val&lt;bPtr.val)&#123;<br>                tail.next = aPtr;<br>                aPtr = aPtr.next;<br>            &#125;else&#123;<br>                tail.next = bPtr;<br>                bPtr = bPtr.next;<br>            &#125;<br>            tail = tail.next;<br>        &#125;<br><br>        tail.next = (aPtr!=null?aPtr:bPtr);<br><br>        return head.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解法二（分治合并）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode next;<br> *     ListNode() &#123;&#125;<br> *     ListNode(int val) &#123; this.val = val; &#125;<br> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public ListNode mergeKLists(ListNode[] lists) &#123;<br>        int n = lists.length;<br>        ListNode ans = null;<br>        for(int i=0;i&lt;n;i++)&#123;<br>            ans = mergeTwoLists(ans, lists[i]);<br>        &#125;<br><br>        return ans;<br>    &#125;<br><br>    public ListNode merge(ListNode[] lists, int l,int r)&#123;<br>        if(l==r)&#123;<br>            return lists[l];<br>        &#125;<br>        if(l&gt;r)&#123;<br>            return null;<br>        &#125;<br>        int mid = (l+r)&gt;&gt;1;<br><br>        return mergeTwoLists(merge(lists,l,mid),merge(lists,mid+1,r));<br>    &#125;<br><br>    public ListNode mergeTwoLists(ListNode a, ListNode b)&#123;<br>        if(a==null||b==null)&#123;<br>            return a!=null?a:b;<br>        &#125;<br><br>        ListNode head = new ListNode(0);<br>        ListNode tail = head, aPtr = a, bPtr = b;<br><br>        while(aPtr!=null&amp;&amp;bPtr!=null)&#123;<br>            if(aPtr.val&lt;bPtr.val)&#123;<br>                tail.next = aPtr;<br>                aPtr = aPtr.next;<br>            &#125;else&#123;<br>                tail.next = bPtr;<br>                bPtr = bPtr.next;<br>            &#125;<br>            tail = tail.next;<br>        &#125;<br><br>        tail.next = (aPtr!=null?aPtr:bPtr);<br><br>        return head.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="503-下一个更大的元素"><a href="#503-下一个更大的元素" class="headerlink" title="503. 下一个更大的元素 ||"></a>503. 下一个更大的元素 ||</h2><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</p>
<p>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</p>
<p>单调栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int[] nextGreaterElements(int[] nums) &#123;<br>        int n = nums.length;<br>        int[] ret = new int[n];<br>        Arrays.fill(ret, -1);<br>        Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();<br>        for(int i=0;i&lt;n*2-1;i++)&#123;<br>            while(!stack.isEmpty()&amp;&amp;nums[stack.peek()]&lt;nums[i%n])&#123;<br>                ret[stack.pop()]=nums[i%n];<br>            &#125;<br>            stack.push(i%n);<br>        &#125;<br><br>        return ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean isValid(String s) &#123;<br>        int n = s.length();<br><br>        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();<br>        for(char c:s.toCharArray())&#123;<br>            if(c==&#x27;(&#x27;)<br>                stack.push(&#x27;)&#x27;);<br>            else if(c==&#x27;&#123;&#x27;)<br>                stack.push(&#x27;&#125;&#x27;);<br>            else if(c==&#x27;]&#x27;)<br>                stack.push(&#x27;]&#x27;);<br><br>            else if(stack.empty()||c!=stack.pop())<br>                return false;<br>        &#125;<br>        <br>        return stack.empty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean isValid(String s) &#123;<br>        Deque&lt;Character&gt; stack = new LinkedList&lt;&gt;();<br><br>        for(char c:s.toCharArray())&#123;<br>            if(c == &#x27;(&#x27;)<br>                stack.addFirst(&#x27;)&#x27;);<br>            else if(c == &#x27;&#123;&#x27;)<br>                stack.addFirst(&#x27;&#125;&#x27;);<br>            else if(c==&#x27;[&#x27;)<br>                stack.addFirst(&#x27;]&#x27;);<br><br>            else if(stack.isEmpty()||c!=stack.pollFirst())<br>                return false;<br>        &#125;<br>        if(stack.isEmpty())<br>            return true;<br>        <br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a>71. 简化路径</h2><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘&#x2F;‘ 开头），请你将其转化为更加简洁的规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’&#x2F;&#x2F;‘）都被视为单个斜杠 ‘&#x2F;‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件&#x2F;目录名称。</p>
<p>请注意，返回的 规范路径 必须遵循下述格式：</p>
<p>始终以斜杠 ‘&#x2F;‘ 开头。<br>两个目录名之间必须只有一个斜杠 ‘&#x2F;‘ 。<br>最后一个目录名（如果存在）不能 以 ‘&#x2F;‘ 结尾。<br>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。<br>返回简化后得到的 规范路径 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public String simplifyPath(String path) &#123;<br>        String[] names = path.split(&quot;/&quot;);<br>        Deque&lt;String&gt; stack = new ArrayDeque&lt;String&gt;();<br>        for(String name:names)&#123;<br>            if(&quot;..&quot;.equals(name))&#123;<br>                if(!stack.isEmpty())&#123;<br>                    stack.pollLast();<br>                &#125;<br>            &#125;else if(name.length()&gt;0&amp;&amp;!&quot;.&quot;.equals(name))&#123;<br>                stack.offerLast(name);<br>            &#125;<br>        &#125;<br>        StringBuilder ans = new StringBuilder();<br>        if(stack.isEmpty())&#123;<br>            ans.append(&#x27;/&#x27;);<br>        &#125;else&#123;<br>            while(!stack.isEmpty())&#123;<br>                ans.append(&#x27;/&#x27;);<br>                ans.append(stack.pollFirst());<br>            &#125;  <br>        &#125;<br>        return ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p>快慢指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for singly-linked list.<br> * class ListNode &#123;<br> *     int val;<br> *     ListNode next;<br> *     ListNode(int x) &#123;<br> *         val = x;<br> *         next = null;<br> *     &#125;<br> * &#125;<br> */<br>public class Solution &#123;<br>    public boolean hasCycle(ListNode head) &#123;<br>        ListNode slow = head;<br>        ListNode fast = head.next;<br><br>        while(slow!=fast)&#123;<br>            if(fast==null||fast.next==null)&#123;<br>                return false;<br>            &#125;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br><br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode next;<br> *     ListNode() &#123;&#125;<br> *     ListNode(int val) &#123; this.val = val; &#125;<br> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;<br>        ListNode pre = new ListNode(0);<br>        ListNode cur = pre;<br><br>        int carry = 0;<br>        while(l1!=null||l2!=null)&#123;<br>            int x = l1 ==null ? 0 :l1.val;<br>            int y = l2 == null ? 0: l2.val;<br>            int sum = x+y+carry;<br><br>            carry = sum/10;<br>            sum = sum %10;<br>            cur.next = new ListNode(sum);<br><br>            cur = cur.next;<br><br>            if(l1!=null)<br>                l1 = l1.next;<br>            if(l2 != null)<br>                l2 = l2.next;<br><br>        &#125;<br><br>        if(carry == 1)&#123;<br>            cur.next = new ListNode(carry);<br>        &#125;<br>        return pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>给定一个二叉树 root ，返回其最大深度。</p>
<p>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;<br> *         this.val = val;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public int maxDepth(TreeNode root) &#123;<br>        if(root == null)<br>            return 0;<br>        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;<br> *         this.val = val;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public int maxDepth(TreeNode root) &#123;<br>       if(root == null)<br>            return 0;<br>        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();<br><br>        queue.offer(root);<br>        int ans = 0;<br>        while(!queue.isEmpty())&#123;<br>            int size = queue.size();<br>            while(size&gt;0)&#123;<br>                TreeNode node = queue.poll();<br>                if(node.left!=null)&#123;<br>                    queue.offer(node.left);<br>                &#125;<br>                if(node.right!=null)&#123;<br>                    queue.offer(node.right);<br>                &#125;<br>                size--;<br>            &#125;<br>            ans++;<br>        &#125;<br><br>        return ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h2><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;<br> *         this.val = val;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public boolean isSameTree(TreeNode p, TreeNode q) &#123;<br>        if(p==null &amp;&amp; q == null)<br>            return true;<br>        else if (p==null || q == null)&#123;<br>            return false;<br>        &#125;else if(p.val != q.val)&#123;<br>            return false;<br>        &#125;else&#123;<br>            return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();<br><br>        List&lt;Integer&gt; output = new ArrayList&lt;Integer&gt;();<br><br>        for(int num:nums)&#123;<br>            output.add(num);<br>        &#125;<br><br>        int n = nums.length;<br>        backtrack(n, output, res, 0);<br>        return res;<br>    &#125;<br><br>    public void backtrack(int n, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, int first)&#123;<br>        if(first==n)&#123;<br>            res.add(new ArrayList&lt;Integer&gt;(output));<br>        &#125;<br>        for(int i = first; i&lt;n;i++)&#123;<br>            Collections.swap(output, first, i);<br>            backtrack(n, output, res, first+1);<br>            Collections.swap(output, first, i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h2><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
<p>你可以按 任何顺序 返回答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        if(k&lt;=0||n&lt;k)&#123;<br>            return res;<br>        &#125;<br><br>        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;();<br>        dfs(n, k, 1, path, res);<br><br>        return res;<br>    &#125;<br><br>    private void dfs(int n, int k, int begin, <br>    Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)&#123;<br>        if(path.size()==k)&#123;<br>            res.add(new ArrayList&lt;&gt;(path));<br>            return;<br>        &#125;<br><br>        for(int i=begin;i&lt;=n;i++)&#123;<br>            path.addLast(i);<br>            dfs(n, k, i+1, path, res);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();<br><br>        int len = candidates.length;<br>        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;();<br>        dfs(candidates, 0, len, target, path, res);<br><br>        return res;<br>    &#125;<br><br>    private void dfs(int[] candidates, int begin, int len, int target, <br>    Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) &#123;<br>        if(target&lt;0)&#123;<br>            return;<br>        &#125;<br>        if(target == 0)&#123;<br>            res.add(new ArrayList&lt;&gt;(path));<br>            return;<br>        &#125;<br><br>        for(int i=begin;i&lt;len;i++)&#123;<br>            path.addLast(candidates[i]);<br>            dfs(candidates, i, len, target - candidates[i], path, res);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>##198. 打家劫舍</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int rob(int[] nums) &#123;<br>        int n = nums.length;<br><br>        int[] dp = new int[n+1];<br>        dp[0]=0;<br>        dp[1]=nums[0];<br><br>        for(int i=2;i&lt;=n;i++)&#123;<br>            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i-1]);<br>        &#125;<br><br>        return dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;<br>        Set&lt;String&gt; word = new HashSet(wordDict);<br><br>        boolean[] dp = new boolean[s.length()+1];<br>        dp[0] = true;<br>        <br>        for(int i =1; i&lt;=s.length();i++)&#123;<br>            for(int j = 0;j&lt;i;j++)&#123;<br>                if(dp[j]&amp;&amp;word.contains(s.substring(j,i)))&#123;<br>                    dp[i] = true;<br>                    break;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="322-零钱互换"><a href="#322-零钱互换" class="headerlink" title="322. 零钱互换"></a>322. 零钱互换</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int coinChange(int[] coins, int amount) &#123;<br>        int n = coins.length;<br>        int max= amount+1;<br>        int[] dp = new int[amount+1];<br>        Arrays.fill(dp, max);<br>        dp[0]=0;<br>        for(int i=1;i&lt;=amount;i++)&#123;<br>            for(int j = 0;j&lt;n;j++)&#123;<br>                if(coins[j]&lt;=i)<br>                    dp[i] = Math.min(dp[i], dp[i-coins[j]]+1);<br>            &#125;<br>        &#125;<br><br>        return dp[amount]&gt;amount?-1:dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的<br>子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int lengthOfLIS(int[] nums) &#123;<br>        int n = nums.length;<br>        int[] dp = new int[n];<br>        int maxans = 1;<br>        dp[0] = 1;<br>        for(int i=1;i&lt;n;i++)&#123;<br>            dp[i]=1;<br>            for(int j=0;j&lt;i;j++)&#123;<br>                if(nums[i]&gt;nums[j])&#123;<br>                dp[i] = Math.max(dp[i], dp[j]+1);<br>                &#125;<br>            &#125;<br>            maxans = Math.max(maxans, dp[i]);<br>            <br>        &#125;<br><br>        return maxans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;<br> *         this.val = val;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public TreeNode invertTree(TreeNode root) &#123;<br>        if(root==null)<br>            return null;<br><br>        TreeNode tmp = root.right;<br>        root.right = root.left;<br>        root.left = tmp;<br><br>        invertTree(root.left);<br>        invertTree(root.right);<br><br>        return root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;<br> *         this.val = val;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public TreeNode invertTree(TreeNode root) &#123;<br>        if(root==null)<br>            return null;<br>        <br>        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();<br><br>        queue.add(root);<br><br>        while(!queue.isEmpty())&#123;<br>            TreeNode tmp = queue.poll();<br>            TreeNode left = tmp.left;<br>            tmp.left = tmp.right;<br>            tmp.right = left;<br><br>            if(tmp.left!=null)&#123;<br>                queue.add(tmp.left);<br>            &#125;<br><br>            if(tmp.right!=null)&#123;<br>                queue.add(tmp.right);<br>            &#125;<br><br>        &#125;<br><br>        return root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;<br> *         this.val = val;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;<br>        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = new HashMap&lt;Integer, Integer&gt;();<br>        int max_depth = -1;<br><br><br>        Queue&lt;TreeNode&gt; nodequeue = new LinkedList&lt;TreeNode&gt;();<br>        Queue&lt;Integer&gt; depthqueue = new LinkedList&lt;Integer&gt;();<br>        List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();<br>        nodequeue.add(root);<br>        depthqueue.add(0);<br><br>        while(!nodequeue.isEmpty())&#123;<br>            TreeNode node = nodequeue.remove();<br>            int depth = depthqueue.remove();<br>            <br>            if(node!=null)&#123;<br>                max_depth = Math.max(max_depth, depth);<br>                rightmostValueAtDepth.put(depth, node.val);<br><br>                nodequeue.add(node.left);<br>                nodequeue.add(node.right);<br>                depthqueue.add(depth + 1);<br>                depthqueue.add(depth + 1);<br>            &#125;<br>        &#125;<br><br>        for(int depth=0;depth&lt;=max_depth;depth++)&#123;<br>            ans.add(rightmostValueAtDepth.get(depth));<br>        &#125;<br>        return ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int[][] merge(int[][] intervals) &#123;<br>        Arrays.sort(intervals, (v1, v2)-&gt;v1[0]-v2[0]);<br><br>        int[][] res = new int[intervals.length][2];<br><br>        int idx = -1;<br><br>        for(int[] interval:intervals)&#123;<br>            if(idx==-1||interval[0]&gt;res[idx][1])&#123;<br>                res[++idx] = interval;<br>            &#125;else&#123;<br>                res[idx][1] = Math.max(interval[1], res[idx][1]);<br>            &#125;<br>        &#125;<br><br>        return Arrays.copyOf(res, idx+1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a>228. 汇总区间</h2><p>给定一个  无重复元素 的 有序 整数数组 nums 。</p>
<p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p>
<p>列表中的每个区间范围 [a,b] 应该按如下格式输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public List&lt;String&gt; summaryRanges(int[] nums) &#123;<br>        LinkedList&lt;String&gt; ans = new LinkedList&lt;&gt;();<br><br>        int n = nums.length;<br>        int i = 0;<br>        while(i&lt;n)&#123;<br>            int low = i;<br>            i++;<br><br>            while(i&lt;n&amp;&amp;nums[i]-nums[i-1]==1)&#123;<br>                i++;<br>            &#125;<br><br>            int high = i -1;<br>            StringBuffer tmp = new StringBuffer(Integer.toString(nums[low]));<br>            if(low&lt;high)&#123;<br>                tmp.append(&quot;-&gt;&quot;);<br>                tmp.append(Integer.toString(nums[high]));<br>            &#125;<br>            ans.add(tmp.toString());<br>        &#125;<br><br>        return ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;<br> *         this.val = val;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public boolean isSymmetric(TreeNode root) &#123;<br>        if(root==null)<br>            return true;<br><br>        return dfs(root.left, root.right);<br>    &#125;<br><br>    private boolean dfs(TreeNode left, TreeNode right)&#123;<br>        if(left==null &amp;&amp; right == null)<br>            return true;<br>        if(left==null||right==null)<br>            return false;<br>        if(left.val!=right.val)<br>            return false;<br>        <br>        return dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;<br> *         this.val = val;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public boolean isSymmetric(TreeNode root) &#123;<br>        if(root == null || (root.left==null&amp;&amp;root.right==null))&#123;<br>            return true;<br>        &#125;<br><br>        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();<br><br>        queue.add(root.left);<br>        queue.add(root.right);<br><br>        while(!queue.isEmpty())&#123;<br>            TreeNode left = queue.poll();<br>            TreeNode right = queue.poll();<br><br>            if(left==null &amp;&amp; right == null)&#123;<br>                continue;<br>            &#125;<br>            if(left==null||right==null)&#123;<br>                return false;<br>            &#125;<br>            if(left.val!=right.val)&#123;<br>                return false;<br>            &#125;<br><br>            queue.add(left.left);<br>            queue.add(right.right);<br><br>            queue.add(left.right);<br>            queue.add(right.left);<br>        &#125;<br><br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p>注意：</p>
<p>有效的算符为 ‘+’、’-‘、’*’ 和 ‘&#x2F;‘ 。<br>每个操作数（运算对象）都可以是一个整数或者另一个表达式。<br>两个整数之间的除法总是 向零截断 。<br>表达式中不含除零运算。<br>输入是一个根据逆波兰表示法表示的算术表达式。<br>答案及所有中间计算结果可以用 32 位 整数表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int evalRPN(String[] tokens) &#123;<br>        Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();<br><br>        for(String s: tokens)&#123;<br>            if(s.equals(&quot;+&quot;))&#123;<br>                Integer val1 = queue.pollFirst();<br>                Integer val2 = queue.pollFirst();<br>                Integer val = val2 + val1;<br>                queue.addFirst(val);<br>            &#125;else if (s.equals(&quot;-&quot;))&#123;<br>                Integer val1 = queue.pollFirst();<br>                Integer val2 = queue.pollFirst();<br>                Integer val = val2 - val1;<br>                queue.addFirst(val);<br>            &#125;else if (s.equals(&quot;/&quot;))&#123;<br>                Integer val1 = queue.pollFirst();<br>                Integer val2 = queue.pollFirst();<br>                Integer val = val2 / val1;<br>                queue.addFirst(val);<br>            &#125;else if(s.equals(&quot;*&quot;))&#123;<br>                Integer val1 = queue.pollFirst();<br>                Integer val2 = queue.pollFirst();<br>                Integer val = val2 * val1;<br>                queue.addFirst(val);<br>            &#125;else&#123;<br>                queue.addFirst(Integer.parseInt(s));<br>            &#125;<br>        &#125;<br><br>        return queue.pollFirst();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h2><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();<br>        for(String str:strs)&#123;<br>            char[] array = str.toCharArray();<br>            Arrays.sort(array);<br>            String key = new String(array);<br>            List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>        &#125;<br><br>        return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    public int longestConsecutive(int[] nums) &#123;<br>        Set&lt;Integer&gt; num_set = new HashSet&lt;&gt;();<br>        for(int num:nums)&#123;<br>            num_set.add(num);<br>        &#125;<br><br>        int max_len = 0;<br>        for(int num:num_set)&#123;<br>            if(!num_set.contains(num-1))&#123;<br>                int currentNum = num;<br>                int cur_len = 1;<br><br>                while(num_set.contains(currentNum+1))&#123;<br>                    currentNum += 1;<br>                    cur_len += 1;<br>                &#125;<br><br>                max_len = Math.max(cur_len, max_len);<br>            &#125;<br>        &#125;<br><br>        return max_len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>
<p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*<br>// Definition for a Node.<br>class Node &#123;<br>    int val;<br>    Node next;<br>    Node random;<br><br>    public Node(int val) &#123;<br>        this.val = val;<br>        this.next = null;<br>        this.random = null;<br>    &#125;<br>&#125;<br>*/<br><br>class Solution &#123;<br>    public Node copyRandomList(Node head) &#123;<br>        if(head == null)<br>            return null;<br>        <br>        Node cur = head;<br>        Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;();<br><br>        while(cur!=null)&#123;<br>            map.put(cur, new Node(cur.val));<br>            cur = cur.next;<br>        &#125;<br><br>        cur = head;<br><br>        while(cur!=null)&#123;<br>            map.get(cur).next = map.get(cur.next);<br>            map.get(cur).random = map.get(cur.random);<br>            cur = cur.next;<br>        &#125;<br><br>        return map.get(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="92-反转链表"><a href="#92-反转链表" class="headerlink" title="92. 反转链表||"></a>92. 反转链表||</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode next;<br> *     ListNode() &#123;&#125;<br> *     ListNode(int val) &#123; this.val = val; &#125;<br> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public ListNode reverseBetween(ListNode head, int left, int right) &#123;<br>        int count = 0;<br>        ListNode reverse = new ListNode(-1);<br>        reverse.next = head;<br>        ListNode pre = reverse;<br><br>        for(int i = 0;i&lt;left-1;i++)&#123;<br>            pre = pre.next;<br>        &#125;<br><br>        ListNode rightNode = pre;<br>        for(int i = 0;i&lt;right-left+1;i++)&#123;<br>            rightNode = rightNode.next;<br>        &#125;<br><br>        ListNode leftNode = pre.next;<br>        ListNode curr = rightNode.next;<br><br>        pre.next = null;<br>        rightNode.next = null;<br><br>        reverseLinkedList(leftNode);<br><br>        pre.next = rightNode;<br>        leftNode.next = curr;<br><br>        return reverse.next;<br>    &#125;<br><br>    private void reverseLinkedList(ListNode head)&#123;<br>        ListNode pre =null;<br>        ListNode cur = head;<br><br>        while(cur!=null)&#123;<br>            ListNode next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
      </div>
    </div>
  </article>
  <div class="post__foot">
    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2024/01/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>网络编程</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2024/01/17/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95%E9%A2%98/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
      </div>
      华为笔试题
    </a>
  
</div>

    
      <div class="related-post">
  <div class="related__head">
  <a href="/tags/%E7%AE%97%E6%B3%95/" class="post-tag">#算法</a>

</div>
  <div class="realated__body">
    
      <div class="null"><div class="null-item"><div class="null-title"><a href="/2024/01/07/常用算法/" title="常用算法" rel="bookmark">常用算法</a></div></div><div class="null-item"><div class="null-title"><a href="/2024/01/17/华为笔试题/" title="华为笔试题" rel="bookmark">华为笔试题</a></div></div><div class="null-item"><div class="null-title"><a href="/2024/01/15/IO流/" title="IO流" rel="bookmark">IO流</a></div></div><div class="null-item"><div class="null-title"><a href="/2024/01/15/Stream流/" title="Stream流" rel="bookmark">Stream流</a></div></div></div>
    
  </div>
</div>

    
    
  </div>

    </div>
    <div class="foot">
      <div class="foot-inner">
        <div class="foot__head">
          
            <div class="foot-line">
              
                <div class="matts">海</div>
              
                <div class="matts">内</div>
              
                <div class="matts">存</div>
              
                <div class="matts">知</div>
              
                <div class="matts">己</div>
              
            </div>
          
            <div class="foot-line">
              
                <div class="matts">天</div>
              
                <div class="matts">涯</div>
              
                <div class="matts">若</div>
              
                <div class="matts">比</div>
              
                <div class="matts">邻</div>
              
            </div>
          
        </div>
        <div class="foot__body">
          
            <div class="foot-item">
              <div class="foot-item__head">朋友</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://jtzhpf.github.io">帅哥</a>
                  </div>
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://nuistgy.github.io">kami</a>
                  </div>
                
                <div class="text">
                  <img alt="link" height="20px" width="20px" src="/images/icon/icon-link+.svg"/>
                  <a class="foot-link"
                     href="mailto:dzc2000919@gmail.com?subject=%E7%94%B3%E8%AF%B7%20Hozen.site%20%E7%9A%84%E5%8F%8B%E9%93%BE%E4%BD%8D%E7%BD%AE">
                  申请友链</a>
                </div>
              </div>
            </div>
          
          
            <div class="foot-item">
              <div class="foot-item__head">账号</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-github.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/dzc2000">dzc2000</a>
                  </div>
                
              </div>
            </div>
          
          <div class="foot-item">
            <div class="foot-item__head">联系</div>
            <div class="foot-item__body">
              <div class="text">
                <img alt="link" height="20px" width="20px" src="/images/icon/icon-email.svg"/>
                <a class="foot-link" href="mailto:dzc2000919@gmail.com">dzc2000919@gmail.com</a>
              </div>
            </div>
          </div>
        </div>
        <div class="copyright">
          <a href="http://dzc2000.github.io">饿了</a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
          <svg width="20" height="20" viewBox="0 0 725 725">
            <path fill-rule="evenodd" fill="rgb(221, 221, 221)" d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z"/>
            <path fill-rule="evenodd" fill="rgb(159, 159, 159)" d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z"/>
            <path fill-rule="evenodd" fill="rgb(0, 0, 0)" d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z"/>
          </svg>
          <a target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">致远</a>&nbsp;驱动
        </div>
      </div>
    </div>
    
    
  

  </body>
</html>